{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "auto-form",
  "title": "Auto Form",
  "description": "Automatically generate forms from Zod schemas with full TypeScript support.",
  "dependencies": [
    "zod",
    "react-hook-form",
    "@hookform/resolvers"
  ],
  "registryDependencies": [
    "button",
    "form",
    "input",
    "checkbox",
    "label",
    "select",
    "radio-group",
    "switch",
    "textarea",
    "calendar",
    "popover"
  ],
  "files": [
    {
      "path": "components/auto-form/common/label.tsx",
      "content": "import { FormLabel } from \"@/components/ui/form\";\nimport { cn } from \"@/lib/utils\";\n\nfunction AutoFormLabel({\n  label,\n  isRequired,\n  className,\n}: {\n  label: string;\n  isRequired: boolean;\n  className?: string;\n}) {\n  return (\n    <>\n      <FormLabel className={cn(className)}>\n        {label}\n        {isRequired && <span className=\"text-destructive\"> *</span>}\n      </FormLabel>\n    </>\n  );\n}\n\nexport default AutoFormLabel;\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/common/tooltip.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction AutoFormTooltip({ fieldConfigItem }: { fieldConfigItem: any }) {\n  return (\n    <>\n      {fieldConfigItem?.description && (\n        <p className=\"text-sm text-gray-500 dark:text-white\">\n          {fieldConfigItem.description}\n        </p>\n      )}\n    </>\n  );\n}\n\nexport default AutoFormTooltip;\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/config.ts",
      "content": "import AutoFormCheckbox from \"./fields/checkbox\";\nimport AutoFormDate from \"./fields/date\";\nimport AutoFormEnum from \"./fields/enum\";\nimport AutoFormInput from \"./fields/input\";\nimport AutoFormNumber from \"./fields/number\";\nimport AutoFormRadioGroup from \"./fields/radio-group\";\nimport AutoFormSwitch from \"./fields/switch\";\nimport AutoFormTextarea from \"./fields/textarea\";\n\nexport const INPUT_COMPONENTS = {\n  checkbox: AutoFormCheckbox,\n  date: AutoFormDate,\n  select: AutoFormEnum,\n  radio: AutoFormRadioGroup,\n  switch: AutoFormSwitch,\n  textarea: AutoFormTextarea,\n  number: AutoFormNumber,\n  fallback: AutoFormInput,\n};\n\n/**\n * Define handlers for specific Zod types.\n * You can expand this object to support more types.\n * \n * Supports both:\n * - Zod v3 style: \"ZodBoolean\", \"ZodEnum\", etc. (from _def.typeName)\n * - Zod v4 style: \"boolean\", \"enum\", etc. (from _def.type)\n */\nexport const DEFAULT_ZOD_HANDLERS: {\n  [key: string]: keyof typeof INPUT_COMPONENTS;\n} = {\n  // Zod v3 style type names\n  ZodBoolean: \"checkbox\",\n  ZodDate: \"date\",\n  ZodEnum: \"select\",\n  ZodNativeEnum: \"select\",\n  ZodNumber: \"number\",\n  // Zod v4 style type names (lowercase, no \"Zod\" prefix)\n  boolean: \"checkbox\",\n  date: \"date\",\n  enum: \"select\",\n  nativeEnum: \"select\",\n  number: \"number\",\n  int: \"number\",\n  float: \"number\",\n};\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/dependencies.ts",
      "content": "import type { FieldValues, UseFormWatch } from \"react-hook-form\";\nimport type { Dependency, EnumValues } from \"./types\";\nimport { DependencyType } from \"./types\";\nimport * as z from \"zod\";\n\nexport default function resolveDependencies<\n  SchemaType extends z.infer<z.ZodObject<any, any>>,\n>(\n  dependencies: Dependency<SchemaType>[],\n  currentFieldName: keyof SchemaType,\n  watch: UseFormWatch<FieldValues>,\n) {\n  let isDisabled = false;\n  let isHidden = false;\n  let isRequired = false;\n  let overrideOptions: EnumValues | undefined;\n\n  const currentFieldValue = watch(currentFieldName as string);\n\n  const currentFieldDependencies = dependencies.filter(\n    (dependency) => dependency.targetField === currentFieldName,\n  );\n  for (const dependency of currentFieldDependencies) {\n    const watchedValue = watch(dependency.sourceField as string);\n\n    const conditionMet = dependency.when(watchedValue, currentFieldValue);\n\n    switch (dependency.type) {\n      case DependencyType.DISABLES:\n        if (conditionMet) {\n          isDisabled = true;\n        }\n        break;\n      case DependencyType.REQUIRES:\n        if (conditionMet) {\n          isRequired = true;\n        }\n        break;\n      case DependencyType.HIDES:\n        if (conditionMet) {\n          isHidden = true;\n        }\n        break;\n      case DependencyType.SETS_OPTIONS:\n        if (conditionMet) {\n          overrideOptions = dependency.options;\n        }\n        break;\n    }\n  }\n\n  return {\n    isDisabled,\n    isHidden,\n    isRequired,\n    overrideOptions,\n  };\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/array.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\";\nimport { Button } from \"@/components/ui/button\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { Plus, Trash } from \"lucide-react\";\nimport { useFieldArray, useForm } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { beautifyObjectName } from \"../utils\";\nimport AutoFormObject from \"./object\";\n\n/**\n * Get the def type from a Zod schema (Zod v4 compatible).\n */\nfunction getDefType(schema: z.ZodType): string {\n  return (schema as any)._zod?.def?.type || \"\";\n}\n\n/**\n * Get the element type from an array or wrapped array schema.\n * Handles: array, optional array, default array, nullable array\n * In Zod v4, array element type is at _zod.def.element\n */\nfunction getArrayElementType(item: z.ZodType): z.ZodType | null {\n  const def = (item as any)._zod?.def;\n  const defType = getDefType(item);\n\n  // Direct array\n  if (defType === \"array\") {\n    return def?.element || null;\n  }\n\n  // Wrapped types (default, optional, nullable) - unwrap and recurse\n  if ([\"default\", \"optional\", \"nullable\"].includes(defType)) {\n    const innerType = def?.innerType;\n    if (innerType) {\n      return getArrayElementType(innerType);\n    }\n  }\n\n  return null;\n}\n\nexport default function AutoFormArray({\n  name,\n  item,\n  form,\n  path = [],\n  fieldConfig,\n}: {\n  name: string;\n  item: z.ZodArray<any> | z.ZodDefault<any>;\n  form: ReturnType<typeof useForm>;\n  path?: string[];\n  fieldConfig?: any;\n}) {\n  // The full path for useFieldArray - path already includes the array name\n  const fieldPath = path.join(\".\");\n  \n  const { fields, append, remove } = useFieldArray({\n    control: form.control,\n    name: fieldPath,\n  });\n  const title = fieldConfig?.label ?? beautifyObjectName(name);\n\n  const itemDefType = getArrayElementType(item);\n\n  return (\n    <AccordionItem value={name} className=\"border-none\">\n      <AccordionTrigger>{title}</AccordionTrigger>\n      <AccordionContent>\n        {fields.map((_field, index) => {\n          const key = _field.id;\n          return (\n            <div className=\"mt-4 flex flex-col\" key={`${key}`}>\n              <AutoFormObject\n                schema={itemDefType as z.ZodObject<any, any>}\n                form={form}\n                fieldConfig={fieldConfig}\n                path={[...path, index.toString()]}\n              />\n              <div className=\"my-4 flex justify-end\">\n                <Button\n                  variant=\"secondary\"\n                  size=\"icon\"\n                  type=\"button\"\n                  className=\"hover:bg-zinc-300 hover:text-black focus:ring-0 focus:ring-offset-0 focus-visible:ring-0 focus-visible:ring-offset-0 dark:bg-white dark:text-black dark:hover:bg-zinc-300 dark:hover:text-black dark:hover:ring-0 dark:hover:ring-offset-0 dark:focus-visible:ring-0 dark:focus-visible:ring-offset-0\"\n                  onClick={() => remove(index)}\n                >\n                  <Trash className=\"size-4 \" />\n                </Button>\n              </div>\n\n              <Separator />\n            </div>\n          );\n        })}\n        <Button\n          type=\"button\"\n          variant=\"secondary\"\n          onClick={() => append({})}\n          className=\"mt-4 flex items-center\"\n        >\n          <Plus className=\"mr-2\" size={16} />\n          Add\n        </Button>\n      </AccordionContent>\n    </AccordionItem>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/checkbox.tsx",
      "content": "import { Checkbox } from \"@/components/ui/checkbox\";\nimport { FormControl, FormItem } from \"@/components/ui/form\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\nimport AutoFormLabel from \"../common/label\";\n\nexport default function AutoFormCheckbox({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  return (\n    <div>\n      <FormItem>\n        <div className=\"mb-3 flex items-center gap-3\">\n          <FormControl>\n            <Checkbox\n              checked={field.value}\n              onCheckedChange={field.onChange}\n              {...fieldProps}\n            />\n          </FormControl>\n          <AutoFormLabel\n            label={fieldConfigItem?.label || label}\n            isRequired={isRequired}\n          />\n        </div>\n      </FormItem>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/date.tsx",
      "content": "import { DatePicker } from \"@/components/ui/date-picker\";\nimport { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\nimport { getBaseType } from \"../utils\";\n\n/**\n * Convert a value to a Date object if needed.\n * Handles both Date objects (from z.date()) and ISO strings (from z.fromJSONSchema with format: date-time)\n */\nfunction toDate(value: unknown): Date | undefined {\n  if (!value) return undefined;\n  if (value instanceof Date) return value;\n  if (typeof value === \"string\") {\n    const date = new Date(value);\n    return isNaN(date.getTime()) ? undefined : date;\n  }\n  return undefined;\n}\n\nexport default function AutoFormDate({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  fieldProps,\n  zodItem,\n}: AutoFormInputComponentProps) {\n  // Determine if the underlying schema expects a Date object or string\n  // z.date() has base type \"ZodDate\", while z.fromJSONSchema with format: date-time creates a ZodString\n  const baseType = getBaseType(zodItem);\n  const expectsDateObject = baseType === \"ZodDate\";\n  \n  const handleChange = (date: Date | undefined) => {\n    if (!date) {\n      field.onChange(undefined);\n      return;\n    }\n    // If the schema is z.date(), pass Date object\n    // If the schema is string (from JSON Schema), pass ISO string\n    if (expectsDateObject) {\n      field.onChange(date);\n    } else {\n      field.onChange(date.toISOString());\n    }\n  };\n\n  return (\n    <FormItem>\n      <AutoFormLabel\n        label={fieldConfigItem?.label || label}\n        isRequired={isRequired}\n      />\n      <FormControl>\n        <DatePicker\n          date={toDate(field.value)}\n          setDate={handleChange}\n          {...fieldProps}\n        />\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/enum.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  FormControl,\n  FormItem,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport * as z from \"zod\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\nimport { getBaseSchema } from \"../utils\";\n\n/**\n * Get enum values from a ZodEnum schema.\n * In Zod v4, enum values are accessed via the .options property or .enum property.\n */\nfunction getEnumValues(schema: z.ZodEnum<any>): string[] {\n  // Zod v4: use .options or .enum to get the array of enum values\n  if (Array.isArray((schema as any).options)) {\n    return (schema as any).options;\n  }\n  // Fallback: try the .enum property which contains {value: value} entries\n  if ((schema as any).enum) {\n    return Object.values((schema as any).enum);\n  }\n  // Last resort: check _zod.def.entries\n  const def = (schema as any)._zod?.def;\n  if (def?.entries) {\n    return Object.values(def.entries);\n  }\n  return [];\n}\n\nexport default function AutoFormEnum({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  zodItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const baseSchema = getBaseSchema(zodItem) as unknown as z.ZodEnum<any>;\n  const baseValues = getEnumValues(baseSchema);\n\n  let values: [string, string][] = [];\n  if (!baseValues || baseValues.length === 0) {\n    values = [];\n  } else {\n    values = baseValues.map((value: string) => [value, value]);\n  }\n\n  function findItem(value: any) {\n    return values.find((item) => item[0] === value);\n  }\n\n  // Guard: Ignore empty value changes when a valid value is already set.\n  // This prevents Radix Select from resetting the value during controlled value transitions.\n  const handleValueChange = (val: string) => {\n    if (val === \"\" && field.value && field.value !== \"\") {\n      return; // Ignore spurious empty value callback\n    }\n    field.onChange(val);\n  };\n\n  return (\n    <FormItem>\n      <AutoFormLabel\n        label={fieldConfigItem?.label || label}\n        isRequired={isRequired}\n      />\n      <FormControl>\n        <Select\n          onValueChange={handleValueChange}\n          value={field.value ?? \"\"}\n          {...fieldProps}\n        >\n          <SelectTrigger className={fieldProps.className}>\n            <SelectValue placeholder={fieldConfigItem.inputProps?.placeholder}>\n              {field.value ? findItem(field.value)?.[1] : \"Select an option\"}\n            </SelectValue>\n          </SelectTrigger>\n          <SelectContent>\n            {values.map(([value, label]) => (\n              <SelectItem value={label} key={value}>\n                {label}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/input.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormInput({\n  label,\n  isRequired,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const { showLabel: _showLabel, ...fieldPropsWithoutShowLabel } = fieldProps;\n  const showLabel = _showLabel === undefined ? true : _showLabel;\n  const type = fieldProps.type || \"text\";\n\n  return (\n    <div className=\"flex flex-row  items-center space-x-2\">\n      <FormItem className=\"flex w-full flex-col justify-start\">\n        {showLabel && (\n          <AutoFormLabel\n            label={fieldConfigItem?.label || label}\n            isRequired={isRequired}\n          />\n        )}\n        <FormControl>\n          <Input type={type} {...fieldPropsWithoutShowLabel} />\n        </FormControl>\n        <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n        <FormMessage />\n      </FormItem>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/number.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormNumber({\n  label,\n  isRequired,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const { showLabel: _showLabel, ...fieldPropsWithoutShowLabel } = fieldProps;\n  const showLabel = _showLabel === undefined ? true : _showLabel;\n\n  return (\n    <FormItem>\n      {showLabel && (\n        <AutoFormLabel\n          label={fieldConfigItem?.label || label}\n          isRequired={isRequired}\n        />\n      )}\n      <FormControl>\n        <Input type=\"number\" {...fieldPropsWithoutShowLabel} />\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/object.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\";\nimport { FormField } from \"@/components/ui/form\";\nimport { useForm, useFormContext } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { DEFAULT_ZOD_HANDLERS, INPUT_COMPONENTS } from \"../config\";\nimport type { Dependency, FieldConfig, FieldConfigItem } from \"../types\";\nimport {\n  beautifyObjectName,\n  getBaseSchema,\n  getBaseType,\n  sortFieldsByOrder,\n  zodToHtmlInputProps,\n} from \"../utils\";\nimport AutoFormArray from \"./array\";\nimport resolveDependencies from \"../dependencies\";\n\nfunction DefaultParent({ children }: { children: React.ReactNode }) {\n  return <>{children}</>;\n}\n\nexport default function AutoFormObject<\n  SchemaType extends z.ZodObject<any, any>,\n>({\n  schema,\n  form,\n  fieldConfig,\n  path = [],\n  dependencies = [],\n}: {\n  schema: SchemaType | z.ZodType<z.infer<SchemaType>>;\n  form: ReturnType<typeof useForm>;\n  fieldConfig?: FieldConfig<z.infer<SchemaType>>;\n  path?: string[];\n  dependencies?: Dependency<z.infer<SchemaType>>[];\n}) {\n  const { watch } = useFormContext(); // Use useFormContext to access the watch function\n\n  if (!schema) {\n    return null;\n  }\n  const { shape } = getBaseSchema<SchemaType>(schema as SchemaType) || {};\n\n  if (!shape) {\n    return null;\n  }\n\n  const handleIfZodNumber = (item: z.ZodType) => {\n    // Check for ZodNumber (Zod v4 uses type in _zod.def)\n    const def = (item as any)._zod?.def;\n    const defType = def?.type;\n    const innerDefType = def?.innerType?._zod?.def?.type;\n\n    const isZodNumber =\n      defType === \"number\" || defType === \"int\" || defType === \"float\";\n    const isInnerZodNumber =\n      innerDefType === \"number\" ||\n      innerDefType === \"int\" ||\n      innerDefType === \"float\";\n\n    if (isZodNumber && def) {\n      def.coerce = true;\n    } else if (isInnerZodNumber && def?.innerType?._zod?.def) {\n      def.innerType._zod.def.coerce = true;\n    }\n\n    return item;\n  };\n\n  const sortedFieldKeys = sortFieldsByOrder(fieldConfig, Object.keys(shape));\n\n  return (\n    <Accordion type=\"multiple\" className=\"space-y-5 border-none\">\n      {sortedFieldKeys.map((name) => {\n        let item = shape[name] as z.ZodType;\n        item = handleIfZodNumber(item);\n        const zodBaseType = getBaseType(item);\n        const itemName = beautifyObjectName(name);\n        const key = [...path, name].join(\".\");\n\n        const {\n          isHidden,\n          isDisabled,\n          isRequired: isRequiredByDependency,\n          overrideOptions,\n        } = resolveDependencies(dependencies, name, watch);\n        if (isHidden) {\n          return null;\n        }\n\n        if (zodBaseType === \"ZodObject\") {\n          return (\n            <AccordionItem value={name} key={key} className=\"border-none\">\n              <AccordionTrigger>{itemName}</AccordionTrigger>\n              <AccordionContent className=\"p-2\">\n                <AutoFormObject\n                  schema={item as unknown as z.ZodObject<any, any>}\n                  form={form}\n                  fieldConfig={(fieldConfig?.[name] ?? {}) as any}\n                  path={[...path, name]}\n                />\n              </AccordionContent>\n            </AccordionItem>\n          );\n        }\n        if (zodBaseType === \"ZodArray\") {\n          return (\n            <AutoFormArray\n              key={key}\n              name={name}\n              item={item as unknown as z.ZodArray<any>}\n              form={form}\n              fieldConfig={fieldConfig?.[name] ?? {}}\n              path={[...path, name]}\n            />\n          );\n        }\n\n        const fieldConfigItem: FieldConfigItem = fieldConfig?.[name] ?? {};\n        const zodInputProps = zodToHtmlInputProps(item);\n        \n        // Determine required status:\n        // 1. If dependency sets required, use that\n        // 2. If fieldConfig explicitly sets required (true/false), use that\n        // 3. Otherwise, use zodInputProps.required\n        let isRequired = isRequiredByDependency || zodInputProps.required || false;\n        if (fieldConfigItem.inputProps?.required !== undefined) {\n          isRequired = fieldConfigItem.inputProps.required;\n        }\n\n        if (overrideOptions) {\n          item = z.enum(overrideOptions) as unknown as z.ZodType;\n        }\n\n        return (\n          <FormField\n            control={form.control as any}\n            name={key}\n            key={key}\n            render={({ field }) => {\n              const inputType =\n                fieldConfigItem.fieldType ??\n                DEFAULT_ZOD_HANDLERS[zodBaseType] ??\n                \"fallback\";\n\n              const InputComponent =\n                typeof inputType === \"function\"\n                  ? inputType\n                  : INPUT_COMPONENTS[inputType];\n\n              const ParentElement =\n                fieldConfigItem.renderParent ?? DefaultParent;\n\n              const defaultValue = fieldConfigItem.inputProps?.defaultValue;\n              const value = field.value ?? defaultValue ?? \"\";\n\n              const fieldProps = {\n                ...zodToHtmlInputProps(item),\n                ...field,\n                ...fieldConfigItem.inputProps,\n                disabled: fieldConfigItem.inputProps?.disabled || isDisabled,\n                ref: undefined,\n                value: value,\n              };\n\n              if (InputComponent === undefined) {\n                return <></>;\n              }\n\n              return (\n                <ParentElement key={`${key}.parent`}>\n                  <InputComponent\n                    zodInputProps={zodInputProps}\n                    field={field}\n                    fieldConfigItem={fieldConfigItem}\n                    label={itemName}\n                    isRequired={isRequired}\n                    zodItem={item}\n                    fieldProps={fieldProps}\n                    className={fieldProps.className}\n                  />\n                </ParentElement>\n              );\n            }}\n          />\n        );\n      })}\n    </Accordion>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/radio-group.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  FormControl,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\nimport * as z from \"zod\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\nimport { getBaseSchema } from \"../utils\";\n\n/**\n * Get enum values from a ZodEnum schema.\n * In Zod v4, enum values are accessed via the .options property or .enum property.\n */\nfunction getEnumValues(schema: z.ZodEnum<any>): string[] {\n  // Zod v4: use .options or .enum to get the array of enum values\n  if (Array.isArray((schema as any).options)) {\n    return (schema as any).options;\n  }\n  // Fallback: try the .enum property which contains {value: value} entries\n  if ((schema as any).enum) {\n    return Object.values((schema as any).enum);\n  }\n  // Last resort: check _zod.def.entries\n  const def = (schema as any)._zod?.def;\n  if (def?.entries) {\n    return Object.values(def.entries);\n  }\n  return [];\n}\n\nexport default function AutoFormRadioGroup({\n  label,\n  isRequired,\n  field,\n  zodItem,\n  fieldProps,\n  fieldConfigItem,\n}: AutoFormInputComponentProps) {\n  const baseSchema = getBaseSchema(zodItem) as unknown as z.ZodEnum<any>;\n  const values = getEnumValues(baseSchema);\n\n  return (\n    <div>\n      <FormItem>\n        <AutoFormLabel\n          label={fieldConfigItem?.label || label}\n          isRequired={isRequired}\n        />\n        <FormControl>\n          <RadioGroup\n            onValueChange={field.onChange}\n            defaultValue={field.value}\n            {...fieldProps}\n          >\n            {values?.map((value: string) => (\n              <FormItem\n                key={value}\n                className=\"mb-2 flex items-center gap-3 space-y-0\"\n              >\n                <FormControl>\n                  <RadioGroupItem value={value} />\n                </FormControl>\n                <FormLabel className=\"font-normal\">{value}</FormLabel>\n              </FormItem>\n            ))}\n          </RadioGroup>\n        </FormControl>\n        <FormMessage />\n      </FormItem>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/switch.tsx",
      "content": "import { FormControl, FormItem } from \"@/components/ui/form\";\nimport { Switch } from \"@/components/ui/switch\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormSwitch({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  return (\n    <div>\n      <FormItem>\n        <div className=\"flex items-center gap-3\">\n          <FormControl>\n            <Switch\n              checked={field.value}\n              onCheckedChange={field.onChange}\n              {...fieldProps}\n            />\n          </FormControl>\n          <AutoFormLabel\n            label={fieldConfigItem?.label || label}\n            isRequired={isRequired}\n          />\n        </div>\n      </FormItem>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/fields/textarea.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport type { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormTextarea({\n  label,\n  isRequired,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const { showLabel: _showLabel, ...fieldPropsWithoutShowLabel } = fieldProps;\n  const showLabel = _showLabel === undefined ? true : _showLabel;\n  return (\n    <FormItem>\n      {showLabel && (\n        <AutoFormLabel\n          label={fieldConfigItem?.label || label}\n          isRequired={isRequired}\n        />\n      )}\n      <FormControl>\n        <Textarea {...fieldPropsWithoutShowLabel} />\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/index.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\";\nimport { Form } from \"@/components/ui/form\";\nimport React from \"react\";\nimport type {\n  DefaultValues,\n  FormState,\n  UseFormReturn,\n} from \"react-hook-form\";\nimport { useForm } from \"react-hook-form\";\nimport { z } from \"zod\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\n\nimport AutoFormObject from \"./fields/object\";\nimport type { Dependency, FieldConfig } from \"./types\";\nimport type { ZodObjectOrWrapped } from \"./utils\";\nimport { getDefaultValues, getObjectFormSchema } from \"./utils\";\n\nexport function AutoFormSubmit({\n  children,\n  className,\n  disabled,\n}: {\n  children?: React.ReactNode;\n  className?: string;\n  disabled?: boolean;\n}) {\n  return (\n    <Button type=\"submit\" disabled={disabled} className={className}>\n      {children ?? \"Submit\"}\n    </Button>\n  );\n}\n\nfunction AutoForm<SchemaType extends ZodObjectOrWrapped>({\n  formSchema,\n  values: valuesProp,\n  onValuesChange: onValuesChangeProp,\n  onParsedValuesChange,\n  onSubmit: onSubmitProp,\n  fieldConfig,\n  children,\n  className,\n  dependencies,\n}: {\n  formSchema: SchemaType;\n  values?: Partial<z.infer<SchemaType>>;\n  onValuesChange?: (\n    values: Partial<z.infer<SchemaType>>,\n    form: UseFormReturn<z.infer<SchemaType>>\n  ) => void;\n  onParsedValuesChange?: (\n    values: Partial<z.infer<SchemaType>>,\n    form: UseFormReturn<z.infer<SchemaType>>\n  ) => void;\n  onSubmit?: (\n    values: z.infer<SchemaType>,\n    form: UseFormReturn<z.infer<SchemaType>>\n  ) => void;\n  fieldConfig?: FieldConfig<z.infer<SchemaType>>;\n  children?:\n    | React.ReactNode\n    | ((formState: FormState<z.infer<SchemaType>>) => React.ReactNode);\n  className?: string;\n  dependencies?: Dependency<z.infer<SchemaType>>[];\n}) {\n  const objectFormSchema = getObjectFormSchema(formSchema);\n  const defaultValues: DefaultValues<z.infer<typeof objectFormSchema>> | null =\n    getDefaultValues(objectFormSchema, fieldConfig);\n\n  const form = useForm<Record<string, unknown>>({\n    // Cast to any to handle Zod v4 type compatibility with @hookform/resolvers\n    resolver: zodResolver(formSchema as any) as any,\n    defaultValues: (defaultValues ?? undefined) as any,\n    values: valuesProp as any,\n  });\n\n  function onSubmit(values: Record<string, unknown>) {\n    const parsedValues = formSchema.safeParse(values);\n    if (parsedValues.success) {\n      onSubmitProp?.(parsedValues.data as z.infer<SchemaType>, form as any);\n    }\n  }\n\n  React.useEffect(() => {\n    const subscription = form.watch((values) => {\n      onValuesChangeProp?.(values as any, form as any);\n      const parsedValues = formSchema.safeParse(values);\n      if (parsedValues.success) {\n        onParsedValuesChange?.(parsedValues.data as any, form as any);\n      }\n    });\n\n    return () => subscription.unsubscribe();\n  }, [form, formSchema, onValuesChangeProp, onParsedValuesChange]);\n\n  const renderChildren =\n    typeof children === \"function\"\n      ? children(form.formState as FormState<z.infer<SchemaType>>)\n      : children;\n\n  return (\n    <div className=\"w-full\">\n      <Form {...form}>\n        <form\n          onSubmit={(e) => {\n            form.handleSubmit(onSubmit)(e);\n          }}\n          className={cn(\"space-y-5\", className)}\n        >\n          <AutoFormObject\n            schema={objectFormSchema}\n            form={form as any}\n            dependencies={dependencies as any}\n            fieldConfig={fieldConfig as any}\n          />\n\n          {renderChildren}\n        </form>\n      </Form>\n    </div>\n  );\n}\n\nexport default AutoForm;\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/types.ts",
      "content": "import type { ControllerRenderProps, FieldValues } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { INPUT_COMPONENTS } from \"./config\";\nimport type { \n  SerializableInputProps,\n  StringInputProps,\n  NumberInputProps,\n  BooleanInputProps,\n  DateInputProps,\n  EnumInputProps,\n  TypedInputProps,\n} from \"../shared-form-types\";\n\n// Re-export discriminated input prop types for field components\nexport type {\n  SerializableInputProps,\n  StringInputProps,\n  NumberInputProps,\n  BooleanInputProps,\n  DateInputProps,\n  EnumInputProps,\n  TypedInputProps,\n};\n\n/**\n * Available field types for AutoForm fieldConfig.\n * These map to the input components in ./config.ts\n */\nexport type AutoFormFieldType = keyof typeof INPUT_COMPONENTS;\n\n/**\n * Input props for form fields.\n * \n * This is the runtime type that accepts any input props.\n * For type-safe props, use the discriminated types:\n * - StringInputProps for text inputs\n * - NumberInputProps for number inputs\n * - BooleanInputProps for checkboxes/switches\n * - DateInputProps for date pickers\n * - EnumInputProps for selects/radios\n */\nexport type FieldInputProps = SerializableInputProps & \n  Omit<React.InputHTMLAttributes<HTMLInputElement>, keyof SerializableInputProps> &\n  Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, keyof SerializableInputProps>;\n\n/**\n * Configuration for a single field in AutoForm.\n * \n * Note: This type is designed to align with form-builder's FormBuilderFieldProps\n * so that JSON Schema properties can be easily converted to field configs.\n */\nexport type FieldConfigItem = {\n  /** Description text or React node */\n  description?: React.ReactNode;\n  /** Input props passed to the field component */\n  inputProps?: FieldInputProps;\n  /** Display label */\n  label?: string;\n  /** Field type override - built-in type or custom component */\n  fieldType?:\n    | keyof typeof INPUT_COMPONENTS\n    | React.FC<AutoFormInputComponentProps>;\n  /** Wrapper component for custom field layout */\n  renderParent?: (props: {\n    children: React.ReactNode;\n  }) => React.ReactElement | null;\n  /** Display order for field ordering */\n  order?: number;\n};\n\n/**\n * FieldConfig for nested objects - allows both FieldConfigItem properties\n * AND nested field configs for child properties.\n */\nexport type FieldConfigObject = FieldConfigItem & {\n  [key: string]: FieldConfigItem | FieldConfigObject | undefined;\n};\n\n/**\n * For object fields, allow both FieldConfigItem properties (label, description, etc.)\n * AND nested field configs for the object's properties.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Required for Zod generic inference\nexport type FieldConfig<SchemaType extends z.infer<z.ZodObject<any, any>>> = {\n  [Key in keyof SchemaType]?: FieldConfigItem | FieldConfigObject;\n};\n\nexport enum DependencyType {\n  DISABLES,\n  REQUIRES,\n  HIDES,\n  SETS_OPTIONS,\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Required for Zod generic inference\ntype BaseDependency<SchemaType extends z.infer<z.ZodObject<any, any>>> = {\n  sourceField: keyof SchemaType;\n  type: DependencyType;\n  targetField: keyof SchemaType;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Dynamic field value types\n  when: (sourceFieldValue: any, targetFieldValue: any) => boolean;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Required for Zod generic inference\nexport type ValueDependency<SchemaType extends z.infer<z.ZodObject<any, any>>> =\n  BaseDependency<SchemaType> & {\n    type:\n      | DependencyType.DISABLES\n      | DependencyType.REQUIRES\n      | DependencyType.HIDES;\n  };\n\nexport type EnumValues = readonly [string, ...string[]];\n\nexport type OptionsDependency<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Required for Zod generic inference\n  SchemaType extends z.infer<z.ZodObject<any, any>>,\n> = BaseDependency<SchemaType> & {\n  type: DependencyType.SETS_OPTIONS;\n\n  // Partial array of values from sourceField that will trigger the dependency\n  options: EnumValues;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Required for Zod generic inference\nexport type Dependency<SchemaType extends z.infer<z.ZodObject<any, any>>> =\n  | ValueDependency<SchemaType>\n  | OptionsDependency<SchemaType>;\n\n/**\n * A FormInput component can handle a specific Zod type (e.g. \"ZodBoolean\")\n */\nexport type AutoFormInputComponentProps = {\n  zodInputProps: React.InputHTMLAttributes<HTMLInputElement>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- react-hook-form field name type\n  field: ControllerRenderProps<FieldValues, any>;\n  fieldConfigItem: FieldConfigItem;\n  label: string;\n  isRequired: boolean;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Dynamic field props from Zod schema\n  fieldProps: any;\n  zodItem: z.ZodType;\n  className?: string;\n};\n",
      "type": "registry:component"
    },
    {
      "path": "components/auto-form/utils.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport React from \"react\";\nimport type { DefaultValues } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport type { AutoFormInputComponentProps, FieldConfig } from \"./types\";\n\n/**\n * Convert a Zod schema to JSON Schema with proper date handling.\n * \n * z.date() is not representable in JSON Schema by default.\n * This helper uses the `override` option to convert z.date() fields\n * to { type: \"string\", format: \"date-time\" } which is the standard\n * JSON Schema representation for dates.\n * \n * This approach is simpler than codecs for form use cases because:\n * - Forms work directly with JavaScript Date objects\n * - z.date() validates Date objects correctly\n * - JSON Schema just needs a string representation for storage/transport\n * \n * Min/max date constraints are preserved as formatMinimum/formatMaximum\n * in the JSON Schema output (JSON Schema draft 7+ format validation).\n */\nexport function toJSONSchemaWithDates<T extends z.ZodType>(schema: T) {\n  return z.toJSONSchema(schema, {\n    unrepresentable: \"any\",\n    override: (ctx) => {\n      const def = (ctx.zodSchema as any)?._zod?.def;\n      if (def?.type === \"date\") {\n        ctx.jsonSchema.type = \"string\";\n        ctx.jsonSchema.format = \"date-time\";\n        \n        // Preserve min/max date constraints\n        // In Zod v4, these are available as minDate/maxDate on the schema object\n        const zodSchema = ctx.zodSchema as any;\n        if (zodSchema.minDate) {\n          // Store as ISO string for JSON Schema format validation\n          ctx.jsonSchema.formatMinimum = zodSchema.minDate;\n        }\n        if (zodSchema.maxDate) {\n          ctx.jsonSchema.formatMaximum = zodSchema.maxDate;\n        }\n      }\n    },\n  });\n}\n\nexport const BUILTIN_FIELD_TYPES = [\n\t\"checkbox\",\n\t\"date\",\n\t\"select\",\n\t\"radio\",\n\t\"switch\",\n\t\"textarea\",\n\t\"number\",\n\t\"file\",\n\t\"fallback\",\n] as const;\n\n/**\n * Get the type name from a Zod v4 schema's _zod.def.\n * In Zod v4: _zod.def.type (e.g., \"default\", \"optional\", \"object\", \"string\")\n */\nfunction getDefTypeName(schema: z.ZodType): string {\n  // Access through _zod.def.type for Zod v4\n  const def = (schema as any)._zod?.def;\n  return def?.type || \"\";\n}\n\n/**\n * Type for wrapped object schemas in Zod v4.\n * In Zod v4, ZodEffects is replaced with ZodPipe for transforms.\n * For autoform purposes, we mainly deal with objects that might be wrapped in optional/default/nullable.\n */\nexport type ZodObjectOrWrapped = z.ZodObject<any, any> | z.ZodType<any>;\n\n/**\n * Beautify a camelCase string.\n * e.g. \"myString\" -> \"My String\"\n */\nexport function beautifyObjectName(string: string) {\n  // if numbers only return the string\n  let output = string.replace(/([A-Z])/g, \" $1\");\n  output = output.charAt(0).toUpperCase() + output.slice(1);\n  return output;\n}\n\n/**\n * Get the lowest level Zod type.\n * This will unpack optionals, defaults, nullables, pipes, etc.\n */\nexport function getBaseSchema<ChildType extends z.ZodType = z.ZodType>(\n  schema: ChildType\n): ChildType | null {\n  if (!schema) return null;\n\n  const def = (schema as any)._zod?.def;\n  if (!def) return schema as ChildType;\n\n  // Handle wrapped types by checking for innerType or wrapped property\n  if (def.innerType) {\n    return getBaseSchema(def.innerType as ChildType);\n  }\n\n  // Handle ZodPipe (transforms) - get the output schema\n  if (def.out) {\n    return getBaseSchema(def.out as ChildType);\n  }\n\n  // Handle schema property (for some wrapper types)\n  if (def.schema) {\n    return getBaseSchema(def.schema as ChildType);\n  }\n\n  return schema as ChildType;\n}\n\n/**\n * Get the type name of the lowest level Zod type.\n * This will unpack optionals, defaults, etc.\n * \n * Returns Zod v4 style type names (e.g., \"enum\", \"boolean\", \"object\")\n */\nexport function getBaseType(schema: z.ZodType): string {\n  const baseSchema = getBaseSchema(schema);\n  if (!baseSchema) return \"\";\n\n  const typeName = getDefTypeName(baseSchema);\n  \n  // Map to consistent type names (capitalize first letter for component lookup)\n  const typeMap: Record<string, string> = {\n    object: \"ZodObject\",\n    array: \"ZodArray\",\n    string: \"ZodString\",\n    number: \"ZodNumber\",\n    int: \"ZodNumber\",\n    float: \"ZodNumber\",\n    boolean: \"ZodBoolean\",\n    date: \"ZodDate\",\n    enum: \"ZodEnum\",\n    nativeEnum: \"ZodNativeEnum\",\n    literal: \"ZodLiteral\",\n    union: \"ZodUnion\",\n  };\n\n  return typeMap[typeName] || typeName;\n}\n\n/**\n * Search for a \"default\" wrapper in the Zod stack and return its value.\n * In Zod v4: _zod.def.defaultValue is the default value (not a function)\n */\nexport function getDefaultValueInZodStack(schema: z.ZodType): any {\n  const def = (schema as any)._zod?.def;\n  if (!def) return undefined;\n\n  if (def.type === \"default\") {\n    // In Zod v4, defaultValue is the value directly (not a function)\n    const defaultValue = def.defaultValue;\n    // Handle both function (legacy) and value\n    if (typeof defaultValue === \"function\") {\n      return defaultValue();\n    }\n    return defaultValue;\n  }\n\n  // Check wrapped types\n  if (def.innerType) {\n    return getDefaultValueInZodStack(def.innerType);\n  }\n  if (def.schema) {\n    return getDefaultValueInZodStack(def.schema);\n  }\n\n  return undefined;\n}\n\n/**\n * Get all default values from a Zod schema.\n */\nexport function getDefaultValues<Schema extends z.ZodObject<any, any>>(\n  schema: Schema,\n  fieldConfig?: FieldConfig<z.infer<Schema>>\n) {\n  if (!schema) return null;\n  const { shape } = schema;\n  type DefaultValuesType = DefaultValues<Partial<z.infer<Schema>>>;\n  const defaultValues = {} as DefaultValuesType;\n  if (!shape) return defaultValues;\n\n  for (const key of Object.keys(shape)) {\n    const item = shape[key] as z.ZodType;\n\n    if (getBaseType(item) === \"ZodObject\") {\n      const defaultItems = getDefaultValues(\n        getBaseSchema(item) as unknown as z.ZodObject<any, any>,\n        fieldConfig?.[key] as FieldConfig<z.infer<Schema>>\n      );\n\n      if (defaultItems !== null) {\n        for (const defaultItemKey of Object.keys(defaultItems)) {\n          const pathKey = `${key}.${defaultItemKey}` as keyof DefaultValuesType;\n          (defaultValues as any)[pathKey] = defaultItems[defaultItemKey];\n        }\n      }\n    } else {\n      let defaultValue = getDefaultValueInZodStack(item);\n      // Also check fieldConfig for default values (important for JSON schema derived forms)\n      if (\n        (defaultValue === undefined || defaultValue === null || defaultValue === \"\") &&\n        fieldConfig?.[key]?.inputProps\n      ) {\n        defaultValue = (fieldConfig?.[key]?.inputProps as unknown as any)\n          .defaultValue;\n      }\n      if (defaultValue !== undefined) {\n        (defaultValues as any)[key as keyof DefaultValuesType] = defaultValue;\n      }\n    }\n  }\n\n  return defaultValues;\n}\n\n/**\n * Extract the object schema from a potentially wrapped schema.\n * Handles pipes, defaults, optionals, etc.\n */\nexport function getObjectFormSchema(\n  schema: ZodObjectOrWrapped\n): z.ZodObject<any, any> {\n  if (!schema) return schema as z.ZodObject<any, any>;\n\n  const def = (schema as any)._zod?.def;\n  if (!def) return schema as z.ZodObject<any, any>;\n\n  // If it's a pipe (transform), get the input schema\n  if (def.type === \"pipe\") {\n    return getObjectFormSchema(def.in);\n  }\n\n  // Handle wrapped types\n  if (def.innerType) {\n    return getObjectFormSchema(def.innerType);\n  }\n  if (def.schema) {\n    return getObjectFormSchema(def.schema);\n  }\n\n  return schema as z.ZodObject<any, any>;\n}\n\n/**\n * Get description from a Zod schema.\n * In Zod v4, descriptions are stored in the global registry.\n */\nexport function getSchemaDescription(schema: z.ZodType): string | undefined {\n  // Try to get from registry first (Zod v4)\n  const registered = z.globalRegistry.get(schema);\n  if (registered?.description) {\n    return registered.description;\n  }\n\n  // Fallback: check if description is on the schema itself\n  const def = (schema as any)._zod?.def;\n  return def?.description;\n}\n\n/**\n * Convert a Zod schema to HTML input props to give direct feedback to the user.\n * Once submitted, the schema will be validated completely.\n */\nexport function zodToHtmlInputProps(\n  schema: z.ZodType\n): React.InputHTMLAttributes<HTMLInputElement> {\n  const def = (schema as any)._zod?.def;\n  const defType = def?.type || \"\";\n\n  // Check for optional/nullable\n  if ([\"optional\", \"nullable\"].includes(defType)) {\n    return {\n      ...zodToHtmlInputProps(def.innerType),\n      required: false,\n    };\n  }\n\n  // Check for default - fields with defaults should not be required\n  // since the default value will be used if not provided\n  if (defType === \"default\") {\n    return {\n      ...zodToHtmlInputProps(def.innerType),\n      required: false,\n    };\n  }\n\n  const inputProps: React.InputHTMLAttributes<HTMLInputElement> = {\n    required: true,\n  };\n\n  // Get checks from the schema\n  const checks = def?.checks;\n  if (!checks || !Array.isArray(checks)) {\n    return inputProps;\n  }\n\n  const type = getBaseType(schema);\n\n  for (const check of checks) {\n    // In Zod v4, checks have 'kind' property\n    const checkKind = check.kind || check.type;\n    \n    if (checkKind === \"min\" || checkKind === \"min_length\") {\n      if (type === \"ZodString\") {\n        inputProps.minLength = check.value ?? check.minimum;\n      } else {\n        inputProps.min = check.value ?? check.minimum;\n      }\n    }\n    if (checkKind === \"max\" || checkKind === \"max_length\") {\n      if (type === \"ZodString\") {\n        inputProps.maxLength = check.value ?? check.maximum;\n      } else {\n        inputProps.max = check.value ?? check.maximum;\n      }\n    }\n  }\n\n  return inputProps;\n}\n\n/**\n * Sort the fields by order.\n * If no order is set, the field will be sorted based on the order in the schema.\n */\nexport function sortFieldsByOrder<SchemaType extends z.ZodObject<any, any>>(\n  fieldConfig: FieldConfig<z.infer<SchemaType>> | undefined,\n  keys: string[]\n) {\n  const sortedFields = keys.sort((a, b) => {\n    const fieldA: number = (fieldConfig?.[a]?.order as number) ?? 0;\n    const fieldB = (fieldConfig?.[b]?.order as number) ?? 0;\n    return fieldA - fieldB;\n  });\n\n  return sortedFields;\n}\n\n// Import shared JSON Schema property type for consistency with form-builder\nimport type { JSONSchemaPropertyBase } from \"../shared-form-types\";\n\n/**\n * JSON schema property shape that includes FieldConfigItem-compatible metadata.\n * Uses the shared type for consistency between form-builder and auto-form.\n */\ntype JsonSchemaProperty = JSONSchemaPropertyBase;\n\n/**\n * Create a Zod schema from JSON Schema with proper date handling.\n * \n * This is the counterpart to toJSONSchemaWithDates. It:\n * 1. Uses z.fromJSONSchema to create the base schema\n * 2. Wraps date fields with validation for formatMinimum/formatMaximum\n * 3. Keeps dates as strings (ISO format) for JSON compatibility\n * \n * The date field component handles converting strings to Date objects for display.\n */\nexport function fromJSONSchemaWithDates(jsonSchema: Record<string, unknown>): z.ZodType {\n\tconst baseSchema = z.fromJSONSchema(jsonSchema);\n\tconst properties = jsonSchema.properties as Record<string, JsonSchemaProperty> | undefined;\n\t\n\tif (!properties) return baseSchema;\n\t\n\t// Find date fields that need validation\n\tconst dateFieldsWithConstraints: Record<string, { min?: string; max?: string }> = {};\n\t\n\tfor (const [key, prop] of Object.entries(properties)) {\n\t\tif (prop.type === \"string\" && prop.format === \"date-time\") {\n\t\t\tif (prop.formatMinimum || prop.formatMaximum) {\n\t\t\t\tdateFieldsWithConstraints[key] = {\n\t\t\t\t\tmin: prop.formatMinimum,\n\t\t\t\t\tmax: prop.formatMaximum,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// If no date constraints, return base schema\n\tif (Object.keys(dateFieldsWithConstraints).length === 0) {\n\t\treturn baseSchema;\n\t}\n\t\n\t// Add refinements for date validation\n\treturn baseSchema.superRefine((data: any, ctx) => {\n\t\tfor (const [key, constraints] of Object.entries(dateFieldsWithConstraints)) {\n\t\t\tconst value = data[key];\n\t\t\tif (value === undefined || value === null || value === \"\") continue;\n\t\t\t\n\t\t\tconst dateValue = new Date(value);\n\t\t\tif (isNaN(dateValue.getTime())) {\n\t\t\t\tctx.addIssue({\n\t\t\t\t\tcode: z.ZodIssueCode.custom,\n\t\t\t\t\tmessage: \"Invalid date\",\n\t\t\t\t\tpath: [key],\n\t\t\t\t});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (constraints.min) {\n\t\t\t\tconst minDate = new Date(constraints.min);\n\t\t\t\tif (dateValue < minDate) {\n\t\t\t\t\tctx.addIssue({\n\t\t\t\t\t\tcode: z.ZodIssueCode.custom,\n\t\t\t\t\t\tmessage: `Date must be after ${minDate.toLocaleDateString()}`,\n\t\t\t\t\t\tpath: [key],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (constraints.max) {\n\t\t\t\tconst maxDate = new Date(constraints.max);\n\t\t\t\tif (dateValue > maxDate) {\n\t\t\t\t\tctx.addIssue({\n\t\t\t\t\t\tcode: z.ZodIssueCode.custom,\n\t\t\t\t\t\tmessage: `Date must be before ${maxDate.toLocaleDateString()}`,\n\t\t\t\t\t\tpath: [key],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function buildFieldConfigFromJsonSchema(\n\tjsonSchema: Record<string, unknown>,\n\tfieldComponents?: Record<\n\t\tstring,\n\t\tReact.ComponentType<AutoFormInputComponentProps>\n\t>,\n): FieldConfig<Record<string, unknown>> {\n\tconst fieldConfig: FieldConfig<Record<string, unknown>> = {};\n\tconst properties = jsonSchema.properties as Record<string, JsonSchemaProperty>;\n\n\tif (!properties) return fieldConfig;\n\n\tfor (const [key, value] of Object.entries(properties)) {\n\t\tconst config: Record<string, unknown> = {};\n\n\t\t// Extract label from meta (support both 'label' and JSON Schema 'title')\n\t\tif (value.label) {\n\t\t\tconfig.label = value.label;\n\t\t} else if (value.title) {\n\t\t\tconfig.label = value.title;\n\t\t}\n\n\t\t// Extract description from meta\n\t\tif (value.description) {\n\t\t\tconfig.description = value.description;\n\t\t}\n\n\t\t// Extract inputProps from meta (includes placeholder, type, etc.)\n\t\t// Also merge in default value if present\n\t\tconst inputProps: Record<string, unknown> = value.inputProps ? { ...value.inputProps } : {};\n\t\t\n\t\t// Extract placeholder from JSON Schema\n\t\tif (value.placeholder) {\n\t\t\tinputProps.placeholder = value.placeholder;\n\t\t}\n\t\t\n\t\t// Extract default value from JSON schema and pass it via inputProps\n\t\t// Also mark field as not required if it has a default value\n\t\tif (value.default !== undefined) {\n\t\t\tinputProps.defaultValue = value.default;\n\t\t\tinputProps.required = false;\n\t\t}\n\t\t\n\t\tif (Object.keys(inputProps).length > 0) {\n\t\t\tconfig.inputProps = inputProps;\n\t\t}\n\n\t\t// Extract order from meta\n\t\tif (value.order !== undefined) {\n\t\t\tconfig.order = value.order;\n\t\t}\n\n\t\t// Extract fieldType from JSON Schema meta\n\t\t// Also detect date-time format from JSON Schema (from z.date() -> toJSONSchema with override)\n\t\tlet fieldType = value.fieldType;\n\t\t\n\t\t// Auto-detect date fields from JSON Schema format: \"date-time\"\n\t\t// This handles the roundtrip: z.date() -> toJSONSchema (with override) -> { type: \"string\", format: \"date-time\" }\n\t\tif (!fieldType && value.type === \"string\" && value.format === \"date-time\") {\n\t\t\tfieldType = \"date\";\n\t\t}\n\n\t\tif (fieldType) {\n\t\t\t// 1. Check if there's a custom component in fieldComponents\n\t\t\tif (fieldComponents?.[fieldType]) {\n\t\t\t\tconst CustomComponent = fieldComponents[fieldType];\n\t\t\t\tconfig.fieldType = (props: AutoFormInputComponentProps) => (\n\t\t\t\t\t<CustomComponent {...props} />\n\t\t\t\t);\n\t\t\t}\n\t\t\t// 2. For built-in types, pass through to auto-form\n\t\t\telse if (\n\t\t\t\tBUILTIN_FIELD_TYPES.includes(\n\t\t\t\t\tfieldType as (typeof BUILTIN_FIELD_TYPES)[number],\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tconfig.fieldType = fieldType;\n\t\t\t}\n\t\t\t// 3. Unknown custom type without a component - log warning and skip\n\t\t\telse {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`CMS: Unknown fieldType \"${fieldType}\" for field \"${key}\". ` +\n\t\t\t\t\t\t`Provide a component via fieldComponents override or use a built-in type.`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Handle nested object properties recursively\n\t\tif (value.properties) {\n\t\t\tconst nestedConfig = buildFieldConfigFromJsonSchema(\n\t\t\t\t{ properties: value.properties } as Record<string, unknown>,\n\t\t\t\tfieldComponents,\n\t\t\t);\n\t\t\t// Merge nested config into this config\n\t\t\tObject.assign(config, nestedConfig);\n\t\t}\n\n\t\tif (Object.keys(config).length > 0) {\n\t\t\tfieldConfig[key] = config;\n\t\t}\n\t}\n\n\treturn fieldConfig;\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport type * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  useFormState,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState } = useFormContext()\n  const formState = useFormState({ name: fieldContext.name })\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nfunction FormItem({ className, ...props }: React.ComponentProps<\"div\">) {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div\n        data-slot=\"form-item\"\n        className={cn(\"grid gap-2\", className)}\n        {...props}\n      />\n    </FormItemContext.Provider>\n  )\n}\n\nfunction FormLabel({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      data-slot=\"form-label\"\n      data-error={!!error}\n      className={cn(\"data-[error=true]:text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n}\n\nfunction FormControl({ ...props }: React.ComponentProps<typeof Slot>) {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      data-slot=\"form-control\"\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n}\n\nfunction FormDescription({ className, ...props }: React.ComponentProps<\"p\">) {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      data-slot=\"form-description\"\n      id={formDescriptionId}\n      className={cn(\"text-muted-foreground text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction FormMessage({ className, ...props }: React.ComponentProps<\"p\">) {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : props.children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      data-slot=\"form-message\"\n      id={formMessageId}\n      className={cn(\"text-destructive text-sm\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n}\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/shared-form-types.ts",
      "content": "/**\n * Shared types between form-builder and auto-form.\n * \n * These types ensure consistency when:\n * - form-builder creates JSON Schema properties\n * - auto-form consumes JSON Schema properties\n * - inputProps flow from form-builder  JSON Schema  auto-form\n */\n\nimport type { INPUT_COMPONENTS } from \"./auto-form/config\";\n\n// ============================================================================\n// INPUT PROPS BY BACKING TYPE\n// ============================================================================\n\n/**\n * Common input props shared by all field types.\n */\nexport interface BaseInputProps {\n  /** Whether the field is disabled */\n  disabled?: boolean;\n  /** Whether the field is read-only */\n  readOnly?: boolean;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Whether to show the label (auto-form specific) */\n  showLabel?: boolean;\n}\n\n/**\n * Input props for string-backed fields (text, email, password, url, phone, textarea).\n */\nexport interface StringInputProps extends BaseInputProps {\n  /** Placeholder text */\n  placeholder?: string;\n  /** HTML input type (text, email, password, tel, url) */\n  type?: \"text\" | \"email\" | \"password\" | \"tel\" | \"url\" | string;\n  /** Default value */\n  defaultValue?: string;\n  /** Minimum length */\n  minLength?: number;\n  /** Maximum length */\n  maxLength?: number;\n  /** Regex pattern for validation */\n  pattern?: string;\n  /** Autocomplete hint */\n  autoComplete?: string;\n}\n\n/**\n * Input props for number-backed fields.\n */\nexport interface NumberInputProps extends BaseInputProps {\n  /** Placeholder text */\n  placeholder?: string;\n  /** Default value */\n  defaultValue?: number;\n  /** Minimum value */\n  min?: number;\n  /** Maximum value */\n  max?: number;\n  /** Step value for increment/decrement */\n  step?: number;\n}\n\n/**\n * Input props for boolean-backed fields (checkbox, switch).\n */\nexport interface BooleanInputProps extends BaseInputProps {\n  /** Default value */\n  defaultValue?: boolean;\n}\n\n/**\n * Input props for date-backed fields.\n */\nexport interface DateInputProps extends BaseInputProps {\n  /** Default value as ISO string or Date */\n  defaultValue?: string | Date;\n  /** Minimum date as ISO string */\n  min?: string;\n  /** Maximum date as ISO string */\n  max?: string;\n}\n\n/**\n * Input props for enum-backed fields (select, radio).\n */\nexport interface EnumInputProps extends BaseInputProps {\n  /** Placeholder text (for select) */\n  placeholder?: string;\n  /** Default value (must match one of the enum options) */\n  defaultValue?: string;\n}\n\n/**\n * Union type of all input props by backing type.\n */\nexport type TypedInputProps = \n  | StringInputProps\n  | NumberInputProps\n  | BooleanInputProps\n  | DateInputProps\n  | EnumInputProps;\n\n/**\n * Generic input props that accept any field type.\n * Use this when the backing type is not known at compile time.\n * \n * This is the catch-all type used for runtime flexibility.\n */\nexport interface SerializableInputProps extends BaseInputProps {\n  placeholder?: string;\n  type?: string;\n  defaultValue?: unknown;\n  min?: number | string;\n  max?: number | string;\n  step?: number | string;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n  autoComplete?: string;\n  /** Allow additional props for extensibility */\n  [key: string]: unknown;\n}\n\n// ============================================================================\n// INPUT PROPS TYPE MAPPING\n// ============================================================================\n\n/**\n * Maps backing Zod types to their corresponding input props type.\n */\nexport interface InputPropsByBackingType {\n  string: StringInputProps;\n  number: NumberInputProps;\n  boolean: BooleanInputProps;\n  date: DateInputProps;\n  enum: EnumInputProps;\n}\n\n/**\n * Get the correct input props type for a backing type.\n */\nexport type InputPropsFor<T extends keyof InputPropsByBackingType> = InputPropsByBackingType[T];\n\n/**\n * Built-in field types supported by auto-form.\n */\nexport type AutoFormBuiltinFieldType = keyof typeof INPUT_COMPONENTS;\n\n/**\n * Field types that can be specified in JSON Schema.\n * Either a built-in type name or a custom component.\n */\nexport type FieldType = \n  | AutoFormBuiltinFieldType\n  | \"color\"  // custom field types used by form-builder\n  | string;  // allow any string for extensibility\n\n/**\n * JSON Schema property with form-builder and auto-form metadata.\n * \n * This is the intermediate format used when:\n * - form-builder serializes field configurations\n * - auto-form parses JSON Schema to build field configs\n */\nexport interface JSONSchemaPropertyBase {\n  // ========================\n  // Standard JSON Schema\n  // ========================\n  /** JSON Schema type */\n  type?: \"string\" | \"number\" | \"integer\" | \"boolean\" | \"object\" | \"array\" | \"null\";\n  /** Human-readable title (JSON Schema standard) */\n  title?: string;\n  /** Description text */\n  description?: string;\n  /** Default value */\n  default?: unknown;\n  /** Enum values for select/radio fields */\n  enum?: (string | number | boolean | null)[];\n  /** Minimum value for numbers */\n  minimum?: number;\n  /** Maximum value for numbers */\n  maximum?: number;\n  /** Exclusive minimum for numbers */\n  exclusiveMinimum?: number;\n  /** Exclusive maximum for numbers */\n  exclusiveMaximum?: number;\n  /** Minimum length for strings */\n  minLength?: number;\n  /** Maximum length for strings */\n  maxLength?: number;\n  /** Regex pattern for strings */\n  pattern?: string;\n  /** Format hint (email, uri, date-time, etc.) */\n  format?: string;\n  /** Multiple of constraint for numbers */\n  multipleOf?: number;\n  \n  // ========================\n  // Nested structures\n  // ========================\n  /** Properties for object types */\n  properties?: Record<string, JSONSchemaPropertyBase>;\n  /** Required fields for object types */\n  required?: string[];\n  /** Additional properties allowed for objects */\n  additionalProperties?: boolean;\n  /** Item schema for array types */\n  items?: JSONSchemaPropertyBase;\n\n  // ========================\n  // Form metadata (via Zod .meta())\n  // ========================\n  /** Display label (form-builder/auto-form) */\n  label?: string;\n  /** Field type override (checkbox, date, select, radio, switch, textarea, etc.) */\n  fieldType?: FieldType;\n  /** Placeholder text */\n  placeholder?: string;\n  /** HTML input type (text, email, password, tel, etc.) */\n  inputType?: string;\n  /** Additional input props */\n  inputProps?: SerializableInputProps;\n  /** Display order */\n  order?: number;\n  \n  // ========================\n  // Date constraints (from toJSONSchemaWithDates)\n  // ========================\n  /** Minimum date as ISO string */\n  formatMinimum?: string;\n  /** Maximum date as ISO string */\n  formatMaximum?: string;\n}\n\n/**\n * Field configuration item that auto-form uses to customize field rendering.\n * This is the target type when converting from JSON Schema.\n * \n * Note: This is kept in sync with auto-form/types.ts FieldConfigItem\n */\nexport interface FieldConfigItemBase {\n  /** Description text or React node */\n  description?: React.ReactNode;\n  /** Input props passed to the field component */\n  inputProps?: SerializableInputProps;\n  /** Display label */\n  label?: string;\n  /** Field type override */\n  fieldType?: FieldType | React.ComponentType<unknown>;\n  /** Wrapper component */\n  renderParent?: (props: { children: React.ReactNode }) => React.ReactElement | null;\n  /** Display order */\n  order?: number;\n}\n\n/**\n * Mapping of JSON Schema property keys to FieldConfigItem keys.\n * Used when converting between formats.\n */\nexport const JSON_SCHEMA_TO_FIELD_CONFIG_MAP = {\n  // Direct mappings\n  label: \"label\",\n  description: \"description\",\n  fieldType: \"fieldType\",\n  inputProps: \"inputProps\",\n  order: \"order\",\n  // Properties that go into inputProps\n  placeholder: \"inputProps.placeholder\",\n  inputType: \"inputProps.type\",\n  default: \"inputProps.defaultValue\",\n} as const;\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:block"
}