{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stepped-auto-form",
  "title": "Stepped Auto Form",
  "description": "Multi-step form wizard built on auto-form with step navigation and validation.",
  "dependencies": [],
  "registryDependencies": [
    "https://raw.githubusercontent.com/better-stack-ai/form-builder/refs/heads/main/registry/auto-form.json",
    "button",
    "separator"
  ],
  "files": [
    {
      "path": "components/ui/auto-form/stepped-auto-form.tsx",
      "content": "\"use client\";\n\nimport React, { useState, useMemo, useCallback, useRef, useEffect } from \"react\";\nimport { z } from \"zod\";\nimport type { UseFormReturn } from \"react-hook-form\";\nimport AutoForm from \"./index\";\nimport { Button } from \"@/components/ui/button\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { cn } from \"@/lib/utils\";\nimport type { FieldConfig } from \"./types\";\nimport type { ZodObjectOrWrapped } from \"./helpers\";\n\nexport default SteppedAutoForm;\nexport { SteppedAutoForm };\nexport type { SteppedAutoFormProps, StepperComponentProps };\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface FormStep {\n  id: string;\n  title: string;\n}\n\ninterface StepperComponentProps {\n  steps: Array<{ id: string; label: string }>;\n  currentStepIndex: number;\n  currentStepId: string;\n  onStepClick?: (stepId: string) => void;\n  isFirst: boolean;\n  isLast: boolean;\n}\n\ninterface SteppedAutoFormProps<SchemaType extends ZodObjectOrWrapped> {\n  // Same props as AutoForm\n  formSchema: SchemaType;\n  values?: Partial<z.infer<SchemaType>>;\n  onValuesChange?: (\n    values: Partial<z.infer<SchemaType>>,\n    form?: UseFormReturn<z.infer<SchemaType>>\n  ) => void;\n  onSubmit?: (values: z.infer<SchemaType>) => void;\n  fieldConfig?: FieldConfig<z.infer<SchemaType>>;\n  children?: React.ReactNode;\n  className?: string;\n\n  // Stepper customization\n  nextButtonText?: string;\n  backButtonText?: string;\n  submitButtonText?: string;\n  StepperComponent?: React.ComponentType<StepperComponentProps>;\n  \n  /** Whether the form is currently submitting. Disables submit/next buttons to prevent duplicate submissions. */\n  isSubmitting?: boolean;\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Extract steps from a Zod schema's JSON Schema representation.\n * Steps are stored in the schema's .meta() and serialized to JSON Schema.\n */\nfunction extractStepsFromSchema(schema: z.ZodType): FormStep[] {\n  try {\n    const jsonSchema = schema.toJSONSchema() as Record<string, unknown>;\n    // Steps are added via .meta({ steps }) and serialized at root level\n    if (jsonSchema.steps && Array.isArray(jsonSchema.steps)) {\n      return jsonSchema.steps as FormStep[];\n    }\n  } catch {\n    // Schema doesn't support toJSONSchema or doesn't have steps\n  }\n  return [];\n}\n\n/**\n * Get field names and their step assignments from JSON Schema.\n * We check both the stepGroupMap from meta and individual field stepGroup properties.\n */\nfunction getFieldStepAssignments(\n  schema: z.ZodType\n): Map<string, number> {\n  const assignments = new Map<string, number>();\n  try {\n    const jsonSchema = schema.toJSONSchema() as Record<string, unknown>;\n    \n    // First, check for stepGroupMap in meta (added when converting from JSON Schema)\n    const stepGroupMap = jsonSchema.stepGroupMap as Record<string, number> | undefined;\n    if (stepGroupMap) {\n      for (const [fieldName, stepGroup] of Object.entries(stepGroupMap)) {\n        assignments.set(fieldName, stepGroup);\n      }\n      return assignments;\n    }\n    \n    // Fallback: check individual field properties for stepGroup\n    const properties = jsonSchema.properties as Record<string, Record<string, unknown>> | undefined;\n    if (properties) {\n      for (const [fieldName, fieldSchema] of Object.entries(properties)) {\n        const stepGroup = fieldSchema.stepGroup;\n        if (typeof stepGroup === \"number\") {\n          assignments.set(fieldName, stepGroup);\n        } else {\n          // Default to step 0 if not specified\n          assignments.set(fieldName, 0);\n        }\n      }\n    }\n  } catch {\n    // Schema doesn't support toJSONSchema\n  }\n  return assignments;\n}\n\n/**\n * Create a partial schema for a specific step by picking only fields that belong to that step\n */\nfunction createStepSchema<T extends z.ZodObject<z.ZodRawShape>>(\n  fullSchema: T,\n  stepIndex: number,\n  fieldAssignments: Map<string, number>\n): z.ZodObject<z.ZodRawShape> {\n  const fieldsForStep = Array.from(fieldAssignments.entries())\n    .filter(([, step]) => step === stepIndex)\n    .map(([field]) => field);\n\n  if (fieldsForStep.length === 0) {\n    // Return empty object schema if no fields\n    return z.object({});\n  }\n\n  // Create pick object\n  const pickObject: Record<string, true> = {};\n  for (const field of fieldsForStep) {\n    pickObject[field] = true;\n  }\n\n  return fullSchema.pick(pickObject) as z.ZodObject<z.ZodRawShape>;\n}\n\n/**\n * Get the inner schema from wrapped Zod types (effects, optional, etc.)\n * In Zod v4, we use duck typing to detect schema types\n */\nfunction getObjectSchema(schema: z.ZodType): z.ZodObject<z.ZodRawShape> | null {\n  // Check if it's a ZodObject by checking for shape property\n  if (schema instanceof z.ZodObject) {\n    return schema as z.ZodObject<z.ZodRawShape>;\n  }\n  \n  // For wrapped types (effects, optional, nullable), try to access inner schema\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const schemaDef = (schema as any)._zod?.def ?? (schema as any)._def;\n  if (schemaDef) {\n    // ZodEffects has schema property\n    if (schemaDef.schema) {\n      return getObjectSchema(schemaDef.schema);\n    }\n    // ZodOptional/ZodNullable have innerType\n    if (schemaDef.innerType) {\n      return getObjectSchema(schemaDef.innerType);\n    }\n  }\n  \n  return null;\n}\n\n// ============================================================================\n// DEFAULT STEPPER COMPONENT\n// ============================================================================\n\nfunction DefaultStepper({\n  steps,\n  currentStepIndex,\n  onStepClick,\n}: StepperComponentProps) {\n  return (\n    <nav aria-label=\"Form Steps\" className=\"mb-6\">\n      <ol className=\"flex items-center justify-between gap-2\">\n        {steps.map((step, index) => (\n          <React.Fragment key={step.id}>\n            <li className=\"flex items-center gap-2 shrink-0\">\n              <Button\n                type=\"button\"\n                variant={index <= currentStepIndex ? \"default\" : \"secondary\"}\n                aria-current={currentStepIndex === index ? \"step\" : undefined}\n                aria-posinset={index + 1}\n                aria-setsize={steps.length}\n                className=\"size-10 rounded-full p-0\"\n                onClick={() => onStepClick?.(step.id)}\n              >\n                {index + 1}\n              </Button>\n              <span className=\"text-sm font-medium hidden sm:inline\">\n                {step.label}\n              </span>\n            </li>\n            {index < steps.length - 1 && (\n              <Separator\n                className={cn(\n                  \"flex-1 min-w-4\",\n                  index < currentStepIndex ? \"bg-primary\" : \"bg-muted\"\n                )}\n              />\n            )}\n          </React.Fragment>\n        ))}\n      </ol>\n    </nav>\n  );\n}\n\n// ============================================================================\n// STEPPED AUTO FORM COMPONENT\n// ============================================================================\n\nfunction SteppedAutoForm<SchemaType extends ZodObjectOrWrapped>({\n  formSchema,\n  values: initialValues,\n  onValuesChange,\n  onSubmit,\n  fieldConfig,\n  children,\n  className,\n  nextButtonText = \"Next\",\n  backButtonText = \"Back\",\n  submitButtonText = \"Submit\",\n  StepperComponent = DefaultStepper,\n  isSubmitting = false,\n}: SteppedAutoFormProps<SchemaType>) {\n  // Extract steps from schema\n  const steps = useMemo(() => extractStepsFromSchema(formSchema), [formSchema]);\n  const hasMultipleSteps = steps.length > 1;\n\n  // Get field assignments\n  const fieldAssignments = useMemo(\n    () => getFieldStepAssignments(formSchema),\n    [formSchema]\n  );\n\n  // State for multi-step form\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [accumulatedValues, setAccumulatedValues] = useState<Record<string, unknown>>(\n    (initialValues as Record<string, unknown>) ?? {}\n  );\n  // Track which steps have been validated/completed (by step index)\n  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());\n  // Track schema validation errors (for cross-field validations)\n  const [schemaErrors, setSchemaErrors] = useState<z.ZodError | null>(null);\n\n  // Refs to avoid stale closures in callbacks - ensures we always have latest values\n  const accumulatedValuesRef = useRef(accumulatedValues);\n  const onValuesChangeRef = useRef(onValuesChange);\n  \n  // Keep refs in sync with current values\n  useEffect(() => {\n    accumulatedValuesRef.current = accumulatedValues;\n  }, [accumulatedValues]);\n  \n  useEffect(() => {\n    onValuesChangeRef.current = onValuesChange;\n  }, [onValuesChange]);\n\n  // Sync accumulated values when the values prop changes externally\n  // This handles async loading scenarios where data arrives after mount\n  useEffect(() => {\n    if (initialValues) {\n      const newValues = {\n        ...accumulatedValuesRef.current,\n        ...(initialValues as Record<string, unknown>),\n      };\n      accumulatedValuesRef.current = newValues;\n      setAccumulatedValues(newValues);\n    }\n  }, [initialValues]);\n\n  // Get the object schema\n  const objectSchema = useMemo(() => getObjectSchema(formSchema), [formSchema]);\n\n  // Create per-step schemas\n  const stepSchemas = useMemo(() => {\n    if (!hasMultipleSteps || !objectSchema) return [];\n    return steps.map((_, index) =>\n      createStepSchema(objectSchema, index, fieldAssignments)\n    );\n  }, [hasMultipleSteps, objectSchema, steps, fieldAssignments]);\n\n  // Current step info\n  const currentStep = steps[currentStepIndex];\n  const currentStepSchema = stepSchemas[currentStepIndex];\n  const isFirst = currentStepIndex === 0;\n  const isLast = currentStepIndex === steps.length - 1;\n\n  // Build field config for current step\n  const currentStepFieldConfig = useMemo(() => {\n    if (!fieldConfig) return undefined;\n    // Filter field config to only include fields for current step\n    const stepFields = Array.from(fieldAssignments.entries())\n      .filter(([, step]) => step === currentStepIndex)\n      .map(([field]) => field);\n    \n    const filtered: Record<string, unknown> = {};\n    for (const field of stepFields) {\n      if (field in (fieldConfig as Record<string, unknown>)) {\n        filtered[field] = (fieldConfig as Record<string, unknown>)[field];\n      }\n    }\n    return filtered as FieldConfig<z.infer<SchemaType>>;\n  }, [fieldConfig, fieldAssignments, currentStepIndex]);\n\n  // Get values for current step\n  const currentStepValues = useMemo(() => {\n    const stepFields = Array.from(fieldAssignments.entries())\n      .filter(([, step]) => step === currentStepIndex)\n      .map(([field]) => field);\n    \n    const values: Record<string, unknown> = {};\n    for (const field of stepFields) {\n      if (field in accumulatedValues) {\n        values[field] = accumulatedValues[field];\n      }\n    }\n    return values;\n  }, [fieldAssignments, currentStepIndex, accumulatedValues]);\n\n  // Handle step navigation - only allow navigation to completed steps or the current step\n  const handleStepClick = useCallback(\n    (stepId: string) => {\n      const stepIndex = steps.findIndex((s) => s.id === stepId);\n      if (stepIndex === -1) return;\n      \n      // Allow navigation only to:\n      // - The current step\n      // - Previously completed steps\n      // - The next step after current (if current step is completed)\n      const canNavigate =\n        stepIndex === currentStepIndex ||\n        completedSteps.has(stepIndex) ||\n        (stepIndex === currentStepIndex + 1 && completedSteps.has(currentStepIndex));\n      \n      if (canNavigate) {\n        setCurrentStepIndex(stepIndex);\n        // Clear schema errors when navigating to allow user to retry\n        setSchemaErrors(null);\n      }\n    },\n    [steps, currentStepIndex, completedSteps]\n  );\n\n  // Handle step value changes - accumulate and notify parent\n  // Uses refs to avoid stale closures, ensuring values from other steps are preserved\n  const handleStepValuesChange = useCallback(\n    (stepValues: Record<string, unknown>, form?: UseFormReturn<Record<string, unknown>>) => {\n      // stepValues contains only the current step's fields, merge with latest accumulated values\n      const newAccumulated = { ...accumulatedValuesRef.current, ...stepValues };\n      accumulatedValuesRef.current = newAccumulated;\n      setAccumulatedValues(newAccumulated);\n      // Notify parent of accumulated values (form is undefined for multi-step as we don't have a single form instance)\n      onValuesChangeRef.current?.(newAccumulated as Partial<z.infer<SchemaType>>, form as UseFormReturn<z.infer<SchemaType>> | undefined);\n    },\n    []\n  );\n\n  // Handle step submission - AutoForm validates per-step, we just accumulate and track completion\n  // Uses refs to avoid stale closures, ensuring values from other steps are preserved\n  const handleStepSubmit = useCallback(\n    (stepValues: Record<string, unknown>) => {\n      // AutoForm has already validated the current step's fields via zodResolver\n      const newAccumulated = { ...accumulatedValuesRef.current, ...stepValues };\n      accumulatedValuesRef.current = newAccumulated;\n      setAccumulatedValues(newAccumulated);\n      \n      // Notify parent of accumulated values (form is undefined for multi-step as we don't have a single form instance)\n      onValuesChangeRef.current?.(newAccumulated as Partial<z.infer<SchemaType>>, undefined);\n      \n      // Mark current step as completed (validation passed via AutoForm)\n      setCompletedSteps((prev) => new Set([...prev, currentStepIndex]));\n\n      if (isLast) {\n        // Final submit - check all steps completed and validate full schema\n        const allStepsCompleted = steps.every(\n          (_, index) => index === currentStepIndex || completedSteps.has(index)\n        );\n        \n        if (!allStepsCompleted) {\n          // Navigate to first incomplete step\n          const firstIncompleteStep = steps.findIndex(\n            (_, index) => index !== currentStepIndex && !completedSteps.has(index)\n          );\n          if (firstIncompleteStep !== -1) {\n            setCurrentStepIndex(firstIncompleteStep);\n            return;\n          }\n        }\n        \n        // Validate against full schema (handles cross-field validations)\n        const parseResult = formSchema.safeParse(newAccumulated);\n        if (parseResult.success) {\n          setSchemaErrors(null);\n          onSubmit?.(parseResult.data as z.infer<SchemaType>);\n        } else {\n          // Store errors to display to the user\n          setSchemaErrors(parseResult.error);\n          \n          // Try to navigate to the step containing the first error\n          const firstErrorPath = parseResult.error.issues[0]?.path[0];\n          if (typeof firstErrorPath === \"string\") {\n            const errorFieldStep = fieldAssignments.get(firstErrorPath);\n            if (errorFieldStep !== undefined && errorFieldStep !== currentStepIndex) {\n              setCurrentStepIndex(errorFieldStep);\n            }\n          }\n        }\n      } else {\n        // Move to next step\n        setCurrentStepIndex((prev) => prev + 1);\n        }\n      },\n    [isLast, onSubmit, currentStepIndex, steps, completedSteps, formSchema, fieldAssignments]\n  );\n\n  // Handle back button\n  const handleBack = useCallback(() => {\n    if (!isFirst) {\n      setCurrentStepIndex((prev) => prev - 1);\n      // Clear schema errors when navigating to allow user to retry\n      setSchemaErrors(null);\n    }\n  }, [isFirst]);\n\n  // If no multiple steps, delegate to regular AutoForm\n  if (!hasMultipleSteps) {\n    return (\n      <AutoForm\n        formSchema={formSchema}\n        values={initialValues}\n        onValuesChange={onValuesChange}\n        onSubmit={onSubmit}\n        fieldConfig={fieldConfig}\n        className={className}\n      >\n        <Button type=\"submit\" disabled={isSubmitting} className=\"w-full mt-4\">\n          {submitButtonText}\n        </Button>\n        {children}\n      </AutoForm>\n    );\n  }\n\n  // Multi-step form rendering\n  if (!currentStepSchema || !currentStep) {\n    return null;\n  }\n\n  return (\n    <div className={cn(\"w-full\", className)}>\n      {/* Stepper Header */}\n      <StepperComponent\n        steps={steps.map((s) => ({ id: s.id, label: s.title }))}\n        currentStepIndex={currentStepIndex}\n        currentStepId={currentStep.id}\n        onStepClick={handleStepClick}\n        isFirst={isFirst}\n        isLast={isLast}\n      />\n\n      {/* Step Title */}\n      <div className=\"mb-4\">\n        <h3 className=\"text-lg font-semibold\">{currentStep.title}</h3>\n        <p className=\"text-sm text-muted-foreground\">\n          Step {currentStepIndex + 1} of {steps.length}\n        </p>\n      </div>\n\n      {/* Schema Validation Errors */}\n      {schemaErrors && schemaErrors.issues.length > 0 && (\n        <div\n          role=\"alert\"\n          aria-live=\"assertive\"\n          className=\"rounded-md border border-destructive/50 bg-destructive/10 p-4 mb-4\"\n        >\n          <div className=\"flex items-start gap-3\">\n            <svg\n              className=\"h-5 w-5 text-destructive shrink-0 mt-0.5\"\n              fill=\"none\"\n              viewBox=\"0 0 24 24\"\n              stroke=\"currentColor\"\n              strokeWidth={2}\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"\n              />\n            </svg>\n            <div className=\"flex-1\">\n              <h4 className=\"text-sm font-medium text-destructive\">\n                Validation Failed\n              </h4>\n              <ul className=\"mt-2 text-sm text-destructive/90 list-disc list-inside space-y-1\">\n                {schemaErrors.issues.map((issue, index) => (\n                  <li key={index}>\n                    {issue.path.length > 0 && (\n                      <span className=\"font-medium\">{issue.path.join(\".\")}: </span>\n                    )}\n                    {issue.message}\n                  </li>\n                ))}\n              </ul>\n            </div>\n            <button\n              type=\"button\"\n              onClick={() => setSchemaErrors(null)}\n              className=\"text-destructive/70 hover:text-destructive shrink-0\"\n              aria-label=\"Dismiss errors\"\n            >\n              <svg className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\" strokeWidth={2}>\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" />\n              </svg>\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Current Step Form */}\n      <AutoForm\n        key={currentStep.id}\n        formSchema={currentStepSchema as z.ZodObject<z.ZodRawShape>}\n        values={currentStepValues}\n        onValuesChange={handleStepValuesChange}\n        onSubmit={handleStepSubmit}\n        fieldConfig={currentStepFieldConfig}\n        className=\"space-y-4\"\n      >\n        {/* Navigation Buttons */}\n        <div className=\"flex justify-between pt-4\">\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={handleBack}\n            disabled={isFirst || isSubmitting}\n          >\n            {backButtonText}\n          </Button>\n          <Button type=\"submit\" disabled={isSubmitting}>\n            {isLast ? submitButtonText : nextButtonText}\n          </Button>\n        </div>\n        {children}\n      </AutoForm>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:block"
}