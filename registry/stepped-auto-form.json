{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stepped-auto-form",
  "title": "Stepped Auto Form",
  "description": "Multi-step form wizard built on auto-form with step navigation and validation.",
  "dependencies": [],
  "registryDependencies": [
    "https://raw.githubusercontent.com/better-stack-ai/form-builder/refs/heads/main/registry/auto-form.json",
    "button",
    "separator"
  ],
  "files": [
    {
      "path": "components/auto-form/stepped-auto-form.tsx",
      "content": "\"use client\";\n\nimport React, { useState, useMemo, useCallback } from \"react\";\nimport { z } from \"zod\";\nimport AutoForm from \"./index\";\nimport { Button } from \"@/components/ui/button\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { cn } from \"@/lib/utils\";\nimport type { FieldConfig } from \"./types\";\nimport type { ZodObjectOrWrapped } from \"./utils\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface FormStep {\n  id: string;\n  title: string;\n}\n\ninterface StepperComponentProps {\n  steps: Array<{ id: string; label: string }>;\n  currentStepIndex: number;\n  currentStepId: string;\n  onStepClick?: (stepId: string) => void;\n  isFirst: boolean;\n  isLast: boolean;\n}\n\ninterface SteppedAutoFormProps<SchemaType extends ZodObjectOrWrapped> {\n  // Same props as AutoForm\n  formSchema: SchemaType;\n  values?: Partial<z.infer<SchemaType>>;\n  onSubmit?: (values: z.infer<SchemaType>) => void;\n  fieldConfig?: FieldConfig<z.infer<SchemaType>>;\n  children?: React.ReactNode;\n  className?: string;\n\n  // Stepper customization\n  nextButtonText?: string;\n  backButtonText?: string;\n  submitButtonText?: string;\n  StepperComponent?: React.ComponentType<StepperComponentProps>;\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Extract steps from a Zod schema's JSON Schema representation.\n * Steps are stored in the schema's .meta() and serialized to JSON Schema.\n */\nfunction extractStepsFromSchema(schema: z.ZodType): FormStep[] {\n  try {\n    const jsonSchema = schema.toJSONSchema() as Record<string, unknown>;\n    // Steps are added via .meta({ steps }) and serialized at root level\n    if (jsonSchema.steps && Array.isArray(jsonSchema.steps)) {\n      return jsonSchema.steps as FormStep[];\n    }\n  } catch {\n    // Schema doesn't support toJSONSchema or doesn't have steps\n  }\n  return [];\n}\n\n/**\n * Get field names and their step assignments from JSON Schema.\n * We check both the stepGroupMap from meta and individual field stepGroup properties.\n */\nfunction getFieldStepAssignments(\n  schema: z.ZodType\n): Map<string, number> {\n  const assignments = new Map<string, number>();\n  try {\n    const jsonSchema = schema.toJSONSchema() as Record<string, unknown>;\n    \n    // First, check for stepGroupMap in meta (added when converting from JSON Schema)\n    const stepGroupMap = jsonSchema.stepGroupMap as Record<string, number> | undefined;\n    if (stepGroupMap) {\n      for (const [fieldName, stepGroup] of Object.entries(stepGroupMap)) {\n        assignments.set(fieldName, stepGroup);\n      }\n      return assignments;\n    }\n    \n    // Fallback: check individual field properties for stepGroup\n    const properties = jsonSchema.properties as Record<string, Record<string, unknown>> | undefined;\n    if (properties) {\n      for (const [fieldName, fieldSchema] of Object.entries(properties)) {\n        const stepGroup = fieldSchema.stepGroup;\n        if (typeof stepGroup === \"number\") {\n          assignments.set(fieldName, stepGroup);\n        } else {\n          // Default to step 0 if not specified\n          assignments.set(fieldName, 0);\n        }\n      }\n    }\n  } catch {\n    // Schema doesn't support toJSONSchema\n  }\n  return assignments;\n}\n\n/**\n * Create a partial schema for a specific step by picking only fields that belong to that step\n */\nfunction createStepSchema<T extends z.ZodObject<z.ZodRawShape>>(\n  fullSchema: T,\n  stepIndex: number,\n  fieldAssignments: Map<string, number>\n): z.ZodObject<z.ZodRawShape> {\n  const fieldsForStep = Array.from(fieldAssignments.entries())\n    .filter(([, step]) => step === stepIndex)\n    .map(([field]) => field);\n\n  if (fieldsForStep.length === 0) {\n    // Return empty object schema if no fields\n    return z.object({});\n  }\n\n  // Create pick object\n  const pickObject: Record<string, true> = {};\n  for (const field of fieldsForStep) {\n    pickObject[field] = true;\n  }\n\n  return fullSchema.pick(pickObject) as z.ZodObject<z.ZodRawShape>;\n}\n\n/**\n * Get the inner schema from wrapped Zod types (effects, optional, etc.)\n * In Zod v4, we use duck typing to detect schema types\n */\nfunction getObjectSchema(schema: z.ZodType): z.ZodObject<z.ZodRawShape> | null {\n  // Check if it's a ZodObject by checking for shape property\n  if (schema instanceof z.ZodObject) {\n    return schema as z.ZodObject<z.ZodRawShape>;\n  }\n  \n  // For wrapped types (effects, optional, nullable), try to access inner schema\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const schemaDef = (schema as any)._zod?.def ?? (schema as any)._def;\n  if (schemaDef) {\n    // ZodEffects has schema property\n    if (schemaDef.schema) {\n      return getObjectSchema(schemaDef.schema);\n    }\n    // ZodOptional/ZodNullable have innerType\n    if (schemaDef.innerType) {\n      return getObjectSchema(schemaDef.innerType);\n    }\n  }\n  \n  return null;\n}\n\n// ============================================================================\n// DEFAULT STEPPER COMPONENT\n// ============================================================================\n\nfunction DefaultStepper({\n  steps,\n  currentStepIndex,\n  onStepClick,\n}: StepperComponentProps) {\n  return (\n    <nav aria-label=\"Form Steps\" className=\"mb-6\">\n      <ol className=\"flex items-center justify-between gap-2\">\n        {steps.map((step, index) => (\n          <React.Fragment key={step.id}>\n            <li className=\"flex items-center gap-2 shrink-0\">\n              <Button\n                type=\"button\"\n                variant={index <= currentStepIndex ? \"default\" : \"secondary\"}\n                aria-current={currentStepIndex === index ? \"step\" : undefined}\n                aria-posinset={index + 1}\n                aria-setsize={steps.length}\n                className=\"size-10 rounded-full p-0\"\n                onClick={() => onStepClick?.(step.id)}\n              >\n                {index + 1}\n              </Button>\n              <span className=\"text-sm font-medium hidden sm:inline\">\n                {step.label}\n              </span>\n            </li>\n            {index < steps.length - 1 && (\n              <Separator\n                className={cn(\n                  \"flex-1 min-w-4\",\n                  index < currentStepIndex ? \"bg-primary\" : \"bg-muted\"\n                )}\n              />\n            )}\n          </React.Fragment>\n        ))}\n      </ol>\n    </nav>\n  );\n}\n\n// ============================================================================\n// STEPPED AUTO FORM COMPONENT\n// ============================================================================\n\nfunction SteppedAutoForm<SchemaType extends ZodObjectOrWrapped>({\n  formSchema,\n  values: initialValues,\n  onSubmit,\n  fieldConfig,\n  children,\n  className,\n  nextButtonText = \"Next\",\n  backButtonText = \"Back\",\n  submitButtonText = \"Submit\",\n  StepperComponent = DefaultStepper,\n}: SteppedAutoFormProps<SchemaType>) {\n  // Extract steps from schema\n  const steps = useMemo(() => extractStepsFromSchema(formSchema), [formSchema]);\n  const hasMultipleSteps = steps.length > 1;\n\n  // Get field assignments\n  const fieldAssignments = useMemo(\n    () => getFieldStepAssignments(formSchema),\n    [formSchema]\n  );\n\n  // State for multi-step form\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [accumulatedValues, setAccumulatedValues] = useState<Record<string, unknown>>(\n    (initialValues as Record<string, unknown>) ?? {}\n  );\n\n  // Get the object schema\n  const objectSchema = useMemo(() => getObjectSchema(formSchema), [formSchema]);\n\n  // Create per-step schemas\n  const stepSchemas = useMemo(() => {\n    if (!hasMultipleSteps || !objectSchema) return [];\n    return steps.map((_, index) =>\n      createStepSchema(objectSchema, index, fieldAssignments)\n    );\n  }, [hasMultipleSteps, objectSchema, steps, fieldAssignments]);\n\n  // Current step info\n  const currentStep = steps[currentStepIndex];\n  const currentStepSchema = stepSchemas[currentStepIndex];\n  const isFirst = currentStepIndex === 0;\n  const isLast = currentStepIndex === steps.length - 1;\n\n  // Build field config for current step\n  const currentStepFieldConfig = useMemo(() => {\n    if (!fieldConfig) return undefined;\n    // Filter field config to only include fields for current step\n    const stepFields = Array.from(fieldAssignments.entries())\n      .filter(([, step]) => step === currentStepIndex)\n      .map(([field]) => field);\n    \n    const filtered: Record<string, unknown> = {};\n    for (const field of stepFields) {\n      if (field in (fieldConfig as Record<string, unknown>)) {\n        filtered[field] = (fieldConfig as Record<string, unknown>)[field];\n      }\n    }\n    return filtered as FieldConfig<z.infer<SchemaType>>;\n  }, [fieldConfig, fieldAssignments, currentStepIndex]);\n\n  // Get values for current step\n  const currentStepValues = useMemo(() => {\n    const stepFields = Array.from(fieldAssignments.entries())\n      .filter(([, step]) => step === currentStepIndex)\n      .map(([field]) => field);\n    \n    const values: Record<string, unknown> = {};\n    for (const field of stepFields) {\n      if (field in accumulatedValues) {\n        values[field] = accumulatedValues[field];\n      }\n    }\n    return values;\n  }, [fieldAssignments, currentStepIndex, accumulatedValues]);\n\n  // Handle step navigation\n  const handleStepClick = useCallback(\n    (stepId: string) => {\n      const stepIndex = steps.findIndex((s) => s.id === stepId);\n      if (stepIndex !== -1) {\n        setCurrentStepIndex(stepIndex);\n      }\n    },\n    [steps]\n  );\n\n  // Handle step submission\n  const handleStepSubmit = useCallback(\n    (stepValues: Record<string, unknown>) => {\n      const newAccumulated = { ...accumulatedValues, ...stepValues };\n      setAccumulatedValues(newAccumulated);\n\n      if (isLast) {\n        // Final submit - validate full schema and call onSubmit\n        onSubmit?.(newAccumulated as z.infer<SchemaType>);\n      } else {\n        // Move to next step\n        setCurrentStepIndex((prev) => prev + 1);\n      }\n    },\n    [accumulatedValues, isLast, onSubmit]\n  );\n\n  // Handle back button\n  const handleBack = useCallback(() => {\n    if (!isFirst) {\n      setCurrentStepIndex((prev) => prev - 1);\n    }\n  }, [isFirst]);\n\n  // If no multiple steps, delegate to regular AutoForm\n  if (!hasMultipleSteps) {\n    return (\n      <AutoForm\n        formSchema={formSchema}\n        values={initialValues}\n        onSubmit={onSubmit}\n        fieldConfig={fieldConfig}\n        className={className}\n      >\n        {children ?? (\n          <Button type=\"submit\" className=\"w-full mt-4\">\n            {submitButtonText}\n          </Button>\n        )}\n      </AutoForm>\n    );\n  }\n\n  // Multi-step form rendering\n  if (!currentStepSchema || !currentStep) {\n    return null;\n  }\n\n  return (\n    <div className={cn(\"w-full\", className)}>\n      {/* Stepper Header */}\n      <StepperComponent\n        steps={steps.map((s) => ({ id: s.id, label: s.title }))}\n        currentStepIndex={currentStepIndex}\n        currentStepId={currentStep.id}\n        onStepClick={handleStepClick}\n        isFirst={isFirst}\n        isLast={isLast}\n      />\n\n      {/* Step Title */}\n      <div className=\"mb-4\">\n        <h3 className=\"text-lg font-semibold\">{currentStep.title}</h3>\n        <p className=\"text-sm text-muted-foreground\">\n          Step {currentStepIndex + 1} of {steps.length}\n        </p>\n      </div>\n\n      {/* Current Step Form */}\n      <AutoForm\n        key={currentStep.id}\n        formSchema={currentStepSchema as z.ZodObject<z.ZodRawShape>}\n        values={currentStepValues}\n        onSubmit={handleStepSubmit}\n        fieldConfig={currentStepFieldConfig}\n        className=\"space-y-4\"\n      >\n        {/* Navigation Buttons */}\n        <div className=\"flex justify-between pt-4\">\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={handleBack}\n            disabled={isFirst}\n          >\n            {backButtonText}\n          </Button>\n          <Button type=\"submit\">\n            {isLast ? submitButtonText : nextButtonText}\n          </Button>\n        </div>\n        {children}\n      </AutoForm>\n    </div>\n  );\n}\n\nexport default SteppedAutoForm;\nexport { SteppedAutoForm };\nexport type { SteppedAutoFormProps, StepperComponentProps };\n\n",
      "type": "registry:component"
    }
  ],
  "type": "registry:block"
}