{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-builder",
  "title": "Form Builder",
  "description": "Visual drag-and-drop form builder with JSON Schema output and live preview.",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/sortable",
    "@dnd-kit/modifiers",
    "@dnd-kit/utilities"
  ],
  "registryDependencies": [
    "https://raw.githubusercontent.com/better-stack-ai/form-builder/refs/heads/main/registry/auto-form.json",
    "tabs",
    "dialog",
    "accordion",
    "separator"
  ],
  "files": [
    {
      "path": "components/form-builder/canvas.tsx",
      "content": "\"use client\";\n\nimport { useMemo } from \"react\";\nimport { useDroppable } from \"@dnd-kit/core\";\nimport {\n  SortableContext,\n  verticalListSortingStrategy,\n} from \"@dnd-kit/sortable\";\nimport { cn } from \"@/lib/utils\";\nimport { SortableField } from \"./sortable-field\";\nimport { StepTabs } from \"./step-tabs\";\nimport type { FormBuilderField, FormBuilderComponentDefinition, FormStep } from \"./types\";\n\ninterface DropZoneProps {\n  id: string;\n  isDraggingFromPalette: boolean;\n}\n\nfunction DropZone({ id, isDraggingFromPalette }: DropZoneProps) {\n  const { setNodeRef, isOver } = useDroppable({\n    id,\n  });\n\n  if (!isDraggingFromPalette) {\n    return null;\n  }\n\n  return (\n    <div\n      ref={setNodeRef}\n      className={cn(\n        \"h-2 rounded-full transition-all duration-200\",\n        isOver\n          ? \"h-3 bg-primary animate-pulse\"\n          : \"bg-muted-foreground/20\"\n      )}\n    />\n  );\n}\n\ninterface CanvasProps {\n  fields: FormBuilderField[];\n  components: FormBuilderComponentDefinition[];\n  onEditField: (id: string) => void;\n  onDeleteField: (id: string) => void;\n  /** Callback to configure nested fields for object/array types */\n  onConfigureNested?: (id: string) => void;\n  isDraggingFromPalette: boolean;\n  className?: string;\n  /** Steps for multi-step forms */\n  steps: FormStep[];\n  /** Currently active step index */\n  activeStepIndex: number;\n  /** Callback when active step changes */\n  onActiveStepChange: (index: number) => void;\n  /** Callback to add a new step */\n  onAddStep: () => void;\n  /** Callback to delete a step */\n  onDeleteStep: (index: number) => void;\n  /** Callback to rename a step */\n  onRenameStep: (index: number, newTitle: string) => void;\n  /** Hide all step controls (used in nested field editor) */\n  hideStepControls?: boolean;\n}\n\nexport function Canvas({\n  fields,\n  components,\n  onEditField,\n  onDeleteField,\n  onConfigureNested,\n  isDraggingFromPalette,\n  className,\n  steps,\n  activeStepIndex,\n  onActiveStepChange,\n  onAddStep,\n  onDeleteStep,\n  onRenameStep,\n  hideStepControls,\n}: CanvasProps) {\n  const { setNodeRef, isOver } = useDroppable({\n    id: \"canvas\",\n  });\n\n  const getComponent = (type: string) =>\n    components.find((c) => c.type === type);\n\n  // Filter fields by active step when there are multiple steps\n  const visibleFields = useMemo(() => {\n    if (steps.length <= 1) {\n      // Single step mode - show all fields\n      return fields;\n    }\n    // Multi-step mode - filter by activeStepIndex\n    return fields.filter((f) => (f.stepGroup ?? 0) === activeStepIndex);\n  }, [fields, steps.length, activeStepIndex]);\n\n  // For sortable context, we only use visible fields\n  const sortableItems = useMemo(() => visibleFields.map((f) => f.id), [visibleFields]);\n\n  return (\n    <div className={cn(\"flex flex-col h-full\", className)}>\n      {/* Step Tabs */}\n      <StepTabs\n        steps={steps}\n        activeStepIndex={activeStepIndex}\n        onActiveStepChange={onActiveStepChange}\n        onAddStep={onAddStep}\n        onDeleteStep={onDeleteStep}\n        onRenameStep={onRenameStep}\n        hideStepControls={hideStepControls}\n      />\n\n      {/* Canvas Drop Area */}\n      <div\n        ref={setNodeRef}\n        data-testid=\"form-builder-canvas\"\n        className={cn(\n          \"flex-1 p-4 rounded-lg border-2 border-dashed min-h-[400px] transition-colors\",\n          isOver && isDraggingFromPalette\n            ? \"border-primary bg-primary/5\"\n            : \"border-muted-foreground/20\"\n        )}\n      >\n        {visibleFields.length === 0 ? (\n          <div className=\"flex flex-col items-center justify-center h-full text-muted-foreground\"  data-testid=\"canvas-drop-zone\">\n            <p className=\"text-lg font-medium\">Drop components here</p>\n            <p className=\"text-sm\">\n              {steps.length > 1\n                ? `Drag components from the palette to add to ${steps[activeStepIndex]?.title || \"this step\"}`\n                : \"Drag components from the palette to build your form\"}\n            </p>\n          </div>\n        ) : (\n          <SortableContext\n            items={sortableItems}\n            strategy={verticalListSortingStrategy}\n          >\n            <div className=\"flex flex-col gap-2\">\n              {/* Drop zone at the beginning */}\n              <DropZone id=\"drop-zone-start\" isDraggingFromPalette={isDraggingFromPalette} />\n              \n              {visibleFields.map((field, index) => (\n                <div key={field.id} className=\"flex flex-col gap-2\">\n                  <SortableField\n                    field={field}\n                    index={index}\n                    component={getComponent(field.type)}\n                    onEdit={() => onEditField(field.id)}\n                    onDelete={() => onDeleteField(field.id)}\n                    onConfigureNested={onConfigureNested ? () => onConfigureNested(field.id) : undefined}\n                  />\n                  {/* Drop zone after each field */}\n                  <DropZone id={`drop-zone-${field.id}`} isDraggingFromPalette={isDraggingFromPalette} />\n                </div>\n              ))}\n            </div>\n          </SortableContext>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/components/index.tsx",
      "content": "import {\n  Type,\n  Mail,\n  Hash,\n  AlignLeft,\n  CheckSquare,\n  ToggleLeft,\n  ChevronDown,\n  Circle,\n  Lock,\n  Globe,\n  Phone,\n  Calendar,\n  FolderOpen,\n  List,\n} from \"lucide-react\";\nimport { z } from \"zod\";\nimport {\n  defineComponent,\n  type FormBuilderComponentDefinition,\n  type FormBuilderFieldProps,\n  type FormBuilderField,\n  type StringFieldProps,\n  type NumberFieldProps,\n  type BooleanFieldProps,\n  type DateFieldProps,\n  type EnumFieldProps,\n  type JSONSchemaProperty,\n} from \"../types\";\nimport {\n  baseMetaSchema,\n  baseMetaSchemaWithPlaceholder,\n  stringValidationSchema,\n  numberValidationSchema,\n  booleanValidationSchema,\n  dateValidationSchema,\n  enumOptionsSchema,\n  objectValidationSchema,\n  arrayValidationSchema,\n  DEFAULT_VALUE_SCHEMAS,\n} from \"../validation-schemas\";\n\n/**\n * Helper to convert a value to a number, handling empty strings and undefined\n */\nfunction toNumber(value: unknown): number | undefined {\n  if (value == null || value === \"\") return undefined;\n  const num = Number(value);\n  return isNaN(num) ? undefined : num;\n}\n\n/**\n * Helper to build inputProps object\n */\nfunction buildInputProps(\n  placeholder?: string,\n  inputType?: string\n): { placeholder?: string; type?: string } | undefined {\n  const props: { placeholder?: string; type?: string } = {};\n  if (placeholder) props.placeholder = placeholder;\n  if (inputType) props.type = inputType;\n  return Object.keys(props).length > 0 ? props : undefined;\n}\n\n/**\n * Helper to extract placeholder from JSONSchemaProperty\n */\nfunction getPlaceholder(prop: JSONSchemaProperty): string | undefined {\n  return prop.inputProps?.placeholder || prop.placeholder;\n}\n\n/**\n * Helper to extract label from JSONSchemaProperty\n */\nfunction getLabel(prop: JSONSchemaProperty, key: string): string {\n  return prop.label || prop.title || key;\n}\n\n/**\n * Text Input Field\n */\nexport const textFieldDefinition = defineComponent<\"string\">({\n  type: \"text\",\n  backingType: \"string\",\n  label: \"Text Input\",\n  icon: Type,\n  defaultProps: {\n    label: \"Text Field\",\n    placeholder: \"\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(stringValidationSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.string })),\n  toJSONSchema: (props: StringFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    inputProps: buildInputProps(props.placeholder),\n    default: props.defaultValue,\n    minLength: toNumber(props.minLength),\n    maxLength: toNumber(props.maxLength),\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    // Match string type without enum or special fieldType or inputProps.type\n    if (\n      prop.type !== \"string\" ||\n      prop.enum ||\n      prop.fieldType ||\n      prop.inputType ||\n      prop.format ||\n      prop.inputProps?.type\n    ) {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"text\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n        minLength: prop.minLength,\n        maxLength: prop.maxLength,\n      },\n    };\n  },\n});\n\n/**\n * Email Input Field\n */\nexport const emailFieldDefinition = defineComponent<\"string\">({\n  type: \"email\",\n  backingType: \"string\",\n  label: \"Email\",\n  icon: Mail,\n  defaultProps: {\n    label: \"Email\",\n    placeholder: \"email@example.com\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.string })),\n  toJSONSchema: (props: StringFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    inputProps: buildInputProps(props.placeholder, \"email\"),\n    default: props.defaultValue,\n    format: \"email\",\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (\n      prop.type !== \"string\" ||\n      (prop.format !== \"email\" && prop.inputType !== \"email\" && prop.inputProps?.type !== \"email\")\n    ) {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"email\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n      },\n    };\n  },\n});\n\n/**\n * Number Input Field\n */\nexport const numberFieldDefinition = defineComponent<\"number\">({\n  type: \"number\",\n  backingType: \"number\",\n  label: \"Number\",\n  icon: Hash,\n  defaultProps: {\n    label: \"Number\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(numberValidationSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.number })),\n  toJSONSchema: (props: NumberFieldProps): JSONSchemaProperty => ({\n    type: \"number\",\n    label: props.label,\n    description: props.description,\n    inputProps: buildInputProps(props.placeholder),\n    default: props.defaultValue,\n    // toNumber handles form input which may come as strings\n    minimum: toNumber(props.min),\n    maximum: toNumber(props.max),\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (prop.type !== \"number\" && prop.type !== \"integer\") {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"number\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as number | undefined,\n        min: prop.minimum,\n        max: prop.maximum,\n      },\n    };\n  },\n});\n\n/**\n * Textarea Field\n */\nexport const textareaFieldDefinition = defineComponent<\"string\">({\n  type: \"textarea\",\n  backingType: \"string\",\n  label: \"Text Area\",\n  icon: AlignLeft,\n  defaultProps: {\n    label: \"Text Area\",\n    placeholder: \"\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(stringValidationSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.string })),\n  toJSONSchema: (props: StringFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    fieldType: \"textarea\",\n    inputProps: buildInputProps(props.placeholder),\n    default: props.defaultValue,\n    minLength: toNumber(props.minLength),\n    maxLength: toNumber(props.maxLength),\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (prop.type !== \"string\" || prop.fieldType !== \"textarea\") {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"textarea\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n        minLength: prop.minLength,\n        maxLength: prop.maxLength,\n      },\n    };\n  },\n});\n\n/**\n * Checkbox Field\n */\nexport const checkboxFieldDefinition = defineComponent<\"boolean\">({\n  type: \"checkbox\",\n  backingType: \"boolean\",\n  label: \"Checkbox\",\n  icon: CheckSquare,\n  defaultProps: {\n    label: \"Checkbox\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchema\n    .merge(booleanValidationSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.boolean })),\n  toJSONSchema: (props: BooleanFieldProps): JSONSchemaProperty => ({\n    type: \"boolean\",\n    label: props.label,\n    description: props.description,\n    default: props.defaultValue,\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (prop.type !== \"boolean\" || prop.fieldType === \"switch\") {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"checkbox\",\n      props: {\n        label: getLabel(prop, key),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as boolean | undefined,\n      },\n    };\n  },\n});\n\n/**\n * Switch Field\n */\nexport const switchFieldDefinition = defineComponent<\"boolean\">({\n  type: \"switch\",\n  backingType: \"boolean\",\n  label: \"Switch\",\n  icon: ToggleLeft,\n  defaultProps: {\n    label: \"Switch\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchema\n    .merge(booleanValidationSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.boolean })),\n  toJSONSchema: (props: BooleanFieldProps): JSONSchemaProperty => ({\n    type: \"boolean\",\n    label: props.label,\n    description: props.description,\n    fieldType: \"switch\",\n    default: props.defaultValue,\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (prop.type !== \"boolean\" || prop.fieldType !== \"switch\") {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"switch\",\n      props: {\n        label: getLabel(prop, key),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as boolean | undefined,\n      },\n    };\n  },\n});\n\n/**\n * Select Field\n */\nexport const selectFieldDefinition = defineComponent<\"enum\">({\n  type: \"select\",\n  backingType: \"enum\",\n  label: \"Select\",\n  icon: ChevronDown,\n  defaultProps: {\n    label: \"Select Field\",\n    required: false,\n    options: [\"Option 1\", \"Option 2\", \"Option 3\"],\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(enumOptionsSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.enum })),\n  toJSONSchema: (props: EnumFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    inputProps: buildInputProps(props.placeholder),\n    default: props.defaultValue,\n    enum: props.options,\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (prop.type !== \"string\" || !prop.enum || prop.fieldType === \"radio\") {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"select\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n        options: prop.enum,\n      },\n    };\n  },\n});\n\n/**\n * Radio Group Field\n */\nexport const radioFieldDefinition = defineComponent<\"enum\">({\n  type: \"radio\",\n  backingType: \"enum\",\n  label: \"Radio Group\",\n  icon: Circle,\n  defaultProps: {\n    label: \"Radio Group\",\n    required: false,\n    options: [\"Option 1\", \"Option 2\", \"Option 3\"],\n  },\n  propertiesSchema: baseMetaSchema\n    .merge(enumOptionsSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.enum })),\n  toJSONSchema: (props: EnumFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    fieldType: \"radio\",\n    default: props.defaultValue,\n    enum: props.options,\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (prop.type !== \"string\" || !prop.enum || prop.fieldType !== \"radio\") {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"radio\",\n      props: {\n        label: getLabel(prop, key),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n        options: prop.enum,\n      },\n    };\n  },\n});\n\n/**\n * Password Input Field\n */\nexport const passwordFieldDefinition = defineComponent<\"string\">({\n  type: \"password\",\n  backingType: \"string\",\n  label: \"Password\",\n  icon: Lock,\n  defaultProps: {\n    label: \"Password\",\n    placeholder: \"••••••••\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(stringValidationSchema)\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.string })),\n  toJSONSchema: (props: StringFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    inputProps: buildInputProps(props.placeholder, \"password\"),\n    default: props.defaultValue,\n    minLength: toNumber(props.minLength),\n    maxLength: toNumber(props.maxLength),\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (\n      prop.type !== \"string\" ||\n      (prop.inputType !== \"password\" && prop.inputProps?.type !== \"password\")\n    ) {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"password\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n        minLength: prop.minLength,\n        maxLength: prop.maxLength,\n      },\n    };\n  },\n});\n\n/**\n * URL/Website Input Field\n */\nexport const urlFieldDefinition = defineComponent<\"string\">({\n  type: \"url\",\n  backingType: \"string\",\n  label: \"Website URL\",\n  icon: Globe,\n  defaultProps: {\n    label: \"Website\",\n    placeholder: \"https://example.com\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.string })),\n  toJSONSchema: (props: StringFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    inputProps: buildInputProps(props.placeholder),\n    default: props.defaultValue,\n    format: \"uri\",\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (prop.type !== \"string\" || prop.format !== \"uri\") {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"url\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n      },\n    };\n  },\n});\n\n/**\n * Phone Input Field\n */\nexport const phoneFieldDefinition = defineComponent<\"string\">({\n  type: \"phone\",\n  backingType: \"string\",\n  label: \"Phone Number\",\n  icon: Phone,\n  defaultProps: {\n    label: \"Phone Number\",\n    placeholder: \"+1 (555) 123-4567\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchemaWithPlaceholder\n    .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.string })),\n  toJSONSchema: (props: StringFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    label: props.label,\n    description: props.description,\n    inputProps: buildInputProps(props.placeholder, \"tel\"),\n    default: props.defaultValue,\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    if (\n      prop.type !== \"string\" ||\n      (prop.inputType !== \"tel\" && prop.inputProps?.type !== \"tel\")\n    ) {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"phone\",\n      props: {\n        label: getLabel(prop, key),\n        placeholder: getPlaceholder(prop),\n        description: prop.description,\n        required: isRequired,\n        defaultValue: prop.default as string | undefined,\n      },\n    };\n  },\n});\n\n/**\n * Date Picker Field\n * \n * Stores dates as ISO datetime strings in JSON Schema (format: \"date-time\")\n * but works with JavaScript Date objects in the form UI.\n */\nexport const dateFieldDefinition = defineComponent<\"date\">({\n  type: \"date\",\n  backingType: \"date\",\n  label: \"Date Picker\",\n  icon: Calendar,\n  defaultProps: {\n    label: \"Date\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchema\n    .merge(dateValidationSchema),\n  toJSONSchema: (props: DateFieldProps): JSONSchemaProperty => ({\n    type: \"string\",\n    format: \"date-time\",\n    fieldType: \"date\",\n    label: props.label,\n    description: props.description,\n  }),\n  fromJSONSchema: (prop, key, isRequired) => {\n    // Match string type with date-time format or explicit date fieldType\n    if (\n      prop.type !== \"string\" ||\n      (prop.format !== \"date-time\" && prop.fieldType !== \"date\")\n    ) {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"date\",\n      props: {\n        label: getLabel(prop, key),\n        description: prop.description,\n        required: isRequired,\n      },\n    };\n  },\n});\n\n/**\n * Object Field (Field Group)\n * \n * A container field that groups other fields together as nested properties.\n * The actual children are stored in field.children and converted by schema-utils.\n */\nexport const objectFieldDefinition: FormBuilderComponentDefinition = {\n  type: \"object\",\n  label: \"Field Group\",\n  icon: FolderOpen,\n  defaultProps: {\n    label: \"Field Group\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchema.extend(objectValidationSchema.shape),\n  toJSONSchema: (props: FormBuilderFieldProps): JSONSchemaProperty => ({\n    type: \"object\",\n    label: props.label,\n    description: props.description,\n    // properties will be filled in by schema-utils from field.children\n    properties: {},\n  }),\n  fromJSONSchema: (prop, key, isRequired): FormBuilderField | null => {\n    // Match object type with properties (not primitive objects without properties)\n    if (prop.type !== \"object\" || !prop.properties) {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"object\",\n      props: {\n        label: getLabel(prop, key),\n        description: prop.description,\n        required: isRequired,\n      },\n      // children will be filled in by schema-utils\n      children: [],\n    };\n  },\n};\n\n/**\n * Array Field (Repeating Group)\n * \n * A container field for repeating items. Each item follows a template defined\n * in field.itemTemplate. The template is converted by schema-utils.\n */\nexport const arrayFieldDefinition: FormBuilderComponentDefinition = {\n  type: \"array\",\n  label: \"Repeating Group\",\n  icon: List,\n  defaultProps: {\n    label: \"Items\",\n    required: false,\n  },\n  propertiesSchema: baseMetaSchema.extend(arrayValidationSchema.shape),\n  toJSONSchema: (props: FormBuilderFieldProps): JSONSchemaProperty => ({\n    type: \"array\",\n    label: props.label,\n    description: props.description,\n    minItems: props.minItems,\n    maxItems: props.maxItems,\n    // items will be filled in by schema-utils from field.itemTemplate\n    items: {\n      type: \"object\",\n      properties: {},\n    },\n  }),\n  fromJSONSchema: (prop, key, isRequired): FormBuilderField | null => {\n    // Match array type with object items\n    if (prop.type !== \"array\" || !prop.items) {\n      return null;\n    }\n    return {\n      id: key,\n      type: \"array\",\n      props: {\n        label: getLabel(prop, key),\n        description: prop.description,\n        required: isRequired,\n        minItems: prop.minItems,\n        maxItems: prop.maxItems,\n      },\n      // itemTemplate will be filled in by schema-utils\n      itemTemplate: [],\n    };\n  },\n};\n\n/**\n * All default components in order of specificity (more specific first)\n * This order matters for fromJSONSchema matching\n * \n * Custom field definitions (color, file, image, etc.) should be created by\n * consumers using the exported `defineComponent` utility and passed via the\n * `components` prop.\n */\nexport const defaultComponents: FormBuilderComponentDefinition[] = [\n  // Container types (must be before primitives to match object/array JSON Schema)\n  objectFieldDefinition,\n  arrayFieldDefinition,\n  // Specific types first\n  emailFieldDefinition,\n  passwordFieldDefinition,\n  urlFieldDefinition,\n  phoneFieldDefinition,\n  dateFieldDefinition,\n  textareaFieldDefinition,\n  switchFieldDefinition,\n  radioFieldDefinition,\n  selectFieldDefinition,\n  checkboxFieldDefinition,\n  numberFieldDefinition,\n  // Generic fallback last\n  textFieldDefinition,\n];\n\n/**\n * Get component definition by type\n */\nexport function getComponentByType(\n  type: string,\n  components: FormBuilderComponentDefinition[] = defaultComponents\n): FormBuilderComponentDefinition | undefined {\n  return components.find((c) => c.type === type);\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/edit-field-dialog.tsx",
      "content": "\"use client\";\n\nimport { useCallback, useMemo, useState } from \"react\";\nimport AutoForm from \"@/components/ui/auto-form\";\nimport { buildFieldConfigFromJsonSchema } from \"@/components/ui/auto-form/utils\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport type {\n  FormBuilderField,\n  FormBuilderComponentDefinition,\n  FormBuilderFieldProps,\n  FormStep,\n} from \"./types\";\n\ninterface EditFieldDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  field: FormBuilderField | null;\n  component: FormBuilderComponentDefinition | null;\n  onUpdate: (id: string, props: Partial<FormBuilderFieldProps>, newId?: string, stepGroup?: number) => void;\n  /** Steps for multi-step forms */\n  steps?: FormStep[];\n  /** All existing field IDs for duplicate validation */\n  allFieldIds?: string[];\n}\n\nexport function EditFieldDialog({\n  open,\n  onOpenChange,\n  field,\n  component,\n  onUpdate,\n  steps = [],\n  allFieldIds = [],\n}: EditFieldDialogProps) {\n  // Compute initial values when field or dialog state changes\n  // We intentionally reset when `open` changes to reinitialize the form\n  const initialValues = useMemo(() => {\n    if (!field) return { fieldName: \"\", props: {}, key: \"\" };\n    const values: Record<string, unknown> = { ...field.props };\n    if (Array.isArray(values.options)) {\n      values.options = (values.options as string[]).join(\"\\n\");\n    }\n    return { fieldName: field.id, props: values, key: `${field.id}-${open}` };\n  }, [field, open]);\n\n  // Track form values locally with overrides\n  const [fieldNameOverride, setFieldNameOverride] = useState<string | null>(null);\n  const [localPropsOverride, setLocalPropsOverride] = useState<Record<string, unknown> | null>(null);\n  const [stepGroupOverride, setStepGroupOverride] = useState<number | null>(null);\n\n  // Use override if set, otherwise use initial values\n  const fieldName = fieldNameOverride ?? initialValues.fieldName;\n  const localProps = localPropsOverride ?? initialValues.props;\n  const localStepGroup = stepGroupOverride ?? field?.stepGroup ?? 0;\n\n  // Check for duplicate field ID (only when changing to a different ID)\n  const isDuplicateId = useMemo(() => {\n    if (!field || fieldName === field.id) return false;\n    return allFieldIds.some((id) => id === fieldName && id !== field.id);\n  }, [fieldName, field, allFieldIds]);\n\n  // Reset overrides when initial values change\n  const [prevInitial, setPrevInitial] = useState(initialValues);\n  if (prevInitial !== initialValues) {\n    setPrevInitial(initialValues);\n    setFieldNameOverride(null);\n    setLocalPropsOverride(null);\n    setStepGroupOverride(null);\n  }\n\n  // Form key for AutoForm reset\n  const formKey = initialValues.key;\n\n  // Handle form value changes\n  const handleValuesChange = useCallback(\n    (values: Record<string, unknown>) => {\n      setLocalPropsOverride(values);\n    },\n    []\n  );\n\n  // Handle save\n  const handleSave = useCallback(() => {\n    if (!field) return;\n\n    // Handle special case for options (string to array)\n    const props: Partial<FormBuilderFieldProps> = { ...localProps };\n    if (typeof props.options === \"string\") {\n      props.options = (props.options as string)\n        .split(\"\\n\")\n        .map((s) => s.trim())\n        .filter(Boolean);\n    }\n\n    // Determine if we need to update the ID\n    const newId = fieldName !== field.id ? fieldName : undefined;\n    \n    // Determine if we need to update the step group\n    // Only pass stepGroup if it was explicitly changed from the field's current value\n    const stepGroup = stepGroupOverride !== null && stepGroupOverride !== field.stepGroup \n      ? stepGroupOverride \n      : undefined;\n    \n    // Single atomic update for props, ID, and step group\n    onUpdate(field.id, props, newId, stepGroup);\n    \n    onOpenChange(false);\n  }, [field, localProps, fieldName, onUpdate, onOpenChange, stepGroupOverride]);\n\n  if (!field || !component) {\n    return null;\n  }\n\n  const Icon = component.icon as React.ComponentType<{ className?: string }>;\n\n  // Build field config from the schema metadata\n  const jsonSchema = component.propertiesSchema.toJSONSchema() as Record<string, unknown>;\n  const fieldConfig = buildFieldConfigFromJsonSchema(jsonSchema);\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-md max-h-[90vh] overflow-y-auto\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            {Icon && <Icon className=\"h-5 w-5 text-muted-foreground\" />}\n            Edit {component.label}\n          </DialogTitle>\n          <DialogDescription>\n            Configure the properties for this field\n          </DialogDescription>\n        </DialogHeader>\n\n        <div className=\"space-y-4 py-4\">\n          {/* Field Name */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"field-name\">Field Name</Label>\n            <Input\n              id=\"field-name\"\n              value={fieldName}\n              onChange={(e) => setFieldNameOverride(e.target.value)}\n              placeholder=\"Enter field name\"\n              className={isDuplicateId ? \"border-destructive focus-visible:ring-destructive\" : \"\"}\n              aria-invalid={isDuplicateId}\n            />\n            {isDuplicateId ? (\n              <p className=\"text-xs text-destructive\">\n                A field with this name already exists. Please choose a different name.\n              </p>\n            ) : (\n              <p className=\"text-xs text-muted-foreground\">\n                This is the key used in the form data and JSON schema\n              </p>\n            )}\n          </div>\n\n          {/* Step Selector (only shown when multiple steps exist) */}\n          {steps.length > 1 && field && (\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"field-step\">Step</Label>\n              <Select\n                value={String(localStepGroup)}\n                onValueChange={(value) => setStepGroupOverride(parseInt(value, 10))}\n              >\n                <SelectTrigger id=\"field-step\">\n                  <SelectValue placeholder=\"Select step\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {steps.map((step, index) => (\n                    <SelectItem key={step.id} value={String(index)}>\n                      {step.title}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n              <p className=\"text-xs text-muted-foreground\">\n                Which step this field belongs to\n              </p>\n            </div>\n          )}\n\n          {/* Properties Form */}\n          <div className=\"border-t pt-4\">\n            <AutoForm\n              key={formKey}\n              formSchema={component.propertiesSchema}\n              values={localProps}\n              onValuesChange={handleValuesChange}\n              fieldConfig={fieldConfig}\n              className=\"space-y-4\"\n            />\n          </div>\n        </div>\n\n        <DialogFooter>\n          <Button variant=\"outline\" onClick={() => onOpenChange(false)}>\n            Cancel\n          </Button>\n          <Button onClick={handleSave} disabled={isDuplicateId}>\n            Save Changes\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/form-preview.tsx",
      "content": "\"use client\";\n\nimport { useState, useMemo } from \"react\";\nimport { SteppedAutoForm } from \"@/components/ui/auto-form/stepped-auto-form\";\nimport { buildFieldConfigFromJsonSchema } from \"@/components/ui/auto-form/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { formSchemaToZod } from \"@/lib/schema-converter\";\nimport type { JSONSchema } from \"./types\";\nimport type { AutoFormInputComponentProps } from \"@/components/ui/auto-form/types\";\n\ninterface FormPreviewProps {\n  schema: JSONSchema;\n  className?: string;\n  /** \n   * Additional custom field components to use in the form preview.\n   * These are merged with the default components (color picker, etc.).\n   */\n  fieldComponents?: Record<string, React.ComponentType<AutoFormInputComponentProps>>;\n  /**\n   * Default values to pre-populate the form with.\n   * Useful for edit scenarios where the form should start with existing data.\n   */\n  defaultValues?: Record<string, unknown>;\n}\n\nexport function FormPreview({ schema, className, fieldComponents, defaultValues }: FormPreviewProps) {\n  const [submittedValues, setSubmittedValues] = useState<Record<string, unknown> | null>(null);\n\n  // Create Zod schema from JSON Schema using the unified converter\n  // This handles: steps metadata, stepGroup mapping, date constraints\n  const zodSchema = useMemo(() => {\n    try {\n      if (!schema.properties || Object.keys(schema.properties).length === 0) {\n        return null;\n      }\n      return formSchemaToZod(schema as unknown as Record<string, unknown>);\n    } catch (error) {\n      console.error(\"Failed to parse JSON Schema:\", error);\n      return null;\n    }\n  }, [schema]);\n\n  // Custom field components for rendering (passed via props)\n  const mergedFieldComponents = useMemo(() => fieldComponents ?? {}, [fieldComponents]);\n\n  // Build field config from JSON Schema with custom components\n  const fieldConfig = useMemo(() => {\n    try {\n      return buildFieldConfigFromJsonSchema(\n        schema as unknown as Record<string, unknown>,\n        mergedFieldComponents\n      );\n    } catch (error) {\n      console.error(\"Failed to build field config:\", error);\n      return {};\n    }\n  }, [schema, mergedFieldComponents]);\n\n  const handleSubmit = (values: unknown) => {\n    setSubmittedValues(values as Record<string, unknown>);\n  };\n\n  const handleReset = () => {\n    setSubmittedValues(null);\n  };\n\n  if (!zodSchema) {\n    return (\n      <div className={cn(\"p-8 text-center text-muted-foreground\", className)}>\n        <p className=\"text-lg font-medium mb-2\">No fields to preview</p>\n        <p className=\"text-sm\">Add some fields to your form to see a preview</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn(\"p-4 md:p-6\", className)}>\n      <div className=\"max-w-2xl mx-auto\">\n        {submittedValues ? (\n          <div className=\"space-y-4\">\n            <div className=\"flex items-center justify-between\">\n              <h3 className=\"text-lg font-semibold\">Submitted Values</h3>\n              <Button variant=\"outline\" onClick={handleReset}>\n                Try Again\n              </Button>\n            </div>\n            <div className=\"rounded-lg border bg-muted/50 p-4\">\n              <pre className=\"text-sm overflow-auto whitespace-pre-wrap\">\n                {JSON.stringify(submittedValues, null, 2)}\n              </pre>\n            </div>\n          </div>\n        ) : (\n          <div className=\"space-y-6\">\n            <div className=\"text-center mb-6\">\n              <h3 className=\"text-lg font-semibold\">Form Preview</h3>\n              <p className=\"text-sm text-muted-foreground\">\n                Test your form and see the submitted values\n              </p>\n            </div>\n            <div className=\"rounded-lg border bg-card p-6\">\n              <SteppedAutoForm\n                formSchema={zodSchema}\n                onSubmit={handleSubmit}\n                fieldConfig={fieldConfig}\n                values={defaultValues}\n                submitButtonText=\"Submit\"\n              />\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/index.tsx",
      "content": "\"use client\";\n\nimport { useCallback, useId, useMemo, useState } from \"react\";\nimport {\n  DndContext,\n  DragOverlay,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  TouchSensor,\n  useSensor,\n  useSensors,\n  type DragEndEvent,\n  type DragStartEvent,\n  type UniqueIdentifier,\n} from \"@dnd-kit/core\";\nimport {\n  arrayMove,\n  sortableKeyboardCoordinates,\n} from \"@dnd-kit/sortable\";\nimport { cn } from \"@/lib/utils\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\n\nimport { Palette, PaletteDragOverlay } from \"./palette\";\nimport { Canvas } from \"./canvas\";\nimport { EditFieldDialog } from \"./edit-field-dialog\";\nimport { NestedFieldEditorDialog } from \"./nested-field-editor-dialog\";\nimport { FormPreview } from \"./form-preview\";\nimport { FieldDragOverlay } from \"./sortable-field\";\nimport { defaultComponents, getComponentByType } from \"./components\";\nimport { fieldsToJSONSchema, jsonSchemaToFieldsAndSteps, generateFieldId, createStep } from \"./schema-utils\";\nimport type {\n  FormBuilderComponentDefinition,\n  FormBuilderField,\n  FormBuilderFieldProps,\n  FormStep,\n  JSONSchema,\n  DragData,\n  PaletteDragData,\n} from \"./types\";\nimport type { AutoFormInputComponentProps } from \"@/components/ui/auto-form/types\";\n\n// Re-export types and components for external use\nexport { defaultComponents, objectFieldDefinition, arrayFieldDefinition } from \"./components\";\nexport { defineComponent } from \"./types\";\nexport { baseMetaSchema, baseMetaSchemaWithPlaceholder } from \"./validation-schemas\";\nexport type {\n  FormBuilderComponentDefinition,\n  FormBuilderField,\n  FormBuilderFieldProps,\n  JSONSchema,\n  JSONSchemaProperty,\n  StringFieldProps,\n} from \"./types\";\n\ninterface FormBuilderProps {\n  /** Available components to use in the form builder */\n  components?: FormBuilderComponentDefinition[];\n  /** Current form schema (JSON Schema format) */\n  value?: JSONSchema;\n  /** Callback when form schema changes */\n  onChange?: (schema: JSONSchema) => void;\n  /** Additional CSS classes */\n  className?: string;\n  /** \n   * Custom field components for the form preview.\n   * Maps fieldType names to React components that render the field.\n   * These are merged with the default custom components (like color picker).\n   * \n   * @example\n   * ```tsx\n   * <FormBuilder\n   *   fieldComponents={{\n   *     rating: RatingComponent,\n   *     signature: SignatureComponent,\n   *   }}\n   * />\n   * ```\n   */\n  fieldComponents?: Record<string, React.ComponentType<AutoFormInputComponentProps>>;\n  /**\n   * Default values to pre-populate the form preview with.\n   * Useful for edit scenarios where the form should start with existing data.\n   * \n   * @example\n   * ```tsx\n   * <FormBuilder\n   *   defaultValues={{\n   *     username: \"johndoe\",\n   *     email: \"john@example.com\",\n   *   }}\n   * />\n   * ```\n   */\n  defaultValues?: Record<string, unknown>;\n}\n\nexport function FormBuilder({\n  components = defaultComponents,\n  value,\n  onChange,\n  className,\n  fieldComponents,\n  defaultValues,\n}: FormBuilderProps) {\n  // Stable ID for DndContext to prevent hydration mismatch\n  const dndContextId = useId();\n  \n  // Internal state - initialized from value prop if provided\n  // Note: To reset fields from parent, use a key prop on FormBuilder\n  const [fields, setFields] = useState<FormBuilderField[]>(() => {\n    if (!value) return [];\n    const { fields: parsedFields } = jsonSchemaToFieldsAndSteps(value, components);\n    return parsedFields;\n  });\n  \n  // Steps state for multi-step forms\n  const [steps, setSteps] = useState<FormStep[]>(() => {\n    if (!value) return [];\n    const { steps: parsedSteps } = jsonSchemaToFieldsAndSteps(value, components);\n    return parsedSteps;\n  });\n  \n  // Active step index for canvas filtering\n  const [activeStepIndex, setActiveStepIndex] = useState(0);\n  \n  const [editDialogFieldId, setEditDialogFieldId] = useState<string | null>(null);\n  const [nestedEditorFieldId, setNestedEditorFieldId] = useState<string | null>(null);\n  const [activeId, setActiveId] = useState<UniqueIdentifier | null>(null);\n\n  // Notify onChange when fields or steps change\n  const notifyChange = useCallback(\n    (newFields: FormBuilderField[], newSteps?: FormStep[]) => {\n      if (onChange) {\n        const schema = fieldsToJSONSchema(newFields, components, newSteps ?? steps);\n        onChange(schema);\n      }\n    },\n    [onChange, components, steps]\n  );\n\n  // Get current JSON Schema for preview\n  const currentSchema = useMemo(\n    () => fieldsToJSONSchema(fields, components, steps),\n    [fields, components, steps]\n  );\n\n  // Sensors for dnd-kit with touch support\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 8,\n      },\n    }),\n    useSensor(TouchSensor, {\n      activationConstraint: {\n        // Use distance instead of delay for better compatibility with\n        // automated testing tools and faster touch interactions\n        distance: 8,\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  // Determine what's being dragged\n  const activeDragData = useMemo(() => {\n    if (!activeId) return null;\n\n    const idStr = String(activeId);\n\n    // Check if it's a palette item\n    if (idStr.startsWith(\"palette-\")) {\n      const componentType = idStr.replace(\"palette-\", \"\");\n      return {\n        type: \"palette\",\n        componentType,\n        component: getComponentByType(componentType, components),\n      };\n    }\n\n    // Otherwise it's a field\n    const field = fields.find((f) => f.id === idStr);\n    if (field) {\n      return {\n        type: \"field\",\n        field,\n        component: getComponentByType(field.type, components),\n      };\n    }\n\n    return null;\n  }, [activeId, fields, components]);\n\n  // Handle drag start\n  const handleDragStart = (event: DragStartEvent) => {\n    setActiveId(event.active.id);\n  };\n\n  // Handle drag end\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event;\n    setActiveId(null);\n\n    if (!over) return;\n\n    const activeData = active.data.current as DragData | undefined;\n\n    // Handle palette item drop\n    if (activeData?.type === \"palette\") {\n      const { componentType } = activeData as PaletteDragData;\n      const component = getComponentByType(componentType, components);\n\n      if (component) {\n        const newField: FormBuilderField = {\n          id: generateFieldId(componentType),\n          type: componentType,\n          props: {\n            label: component.defaultProps.label || component.label,\n            ...component.defaultProps,\n          },\n          // Assign to active step when in multi-step mode\n          ...(steps.length > 1 ? { stepGroup: activeStepIndex } : {}),\n        };\n\n        // Determine insertion index based on where item was dropped\n        let insertIndex = fields.length;\n        const overId = String(over.id);\n        \n        if (overId === \"drop-zone-start\") {\n          // Dropped at the beginning\n          insertIndex = 0;\n        } else if (overId.startsWith(\"drop-zone-\")) {\n          // Dropped after a specific field\n          const fieldId = overId.replace(\"drop-zone-\", \"\");\n          const overIndex = fields.findIndex((f) => f.id === fieldId);\n          if (overIndex !== -1) {\n            insertIndex = overIndex + 1;\n          }\n        } else if (overId !== \"canvas\") {\n          // Dropped directly on a field\n          const overIndex = fields.findIndex((f) => f.id === overId);\n          if (overIndex !== -1) {\n            insertIndex = overIndex + 1;\n          }\n        }\n\n        const newFields = [...fields];\n        newFields.splice(insertIndex, 0, newField);\n        setFields(newFields);\n        notifyChange(newFields);\n      }\n      return;\n    }\n\n    // Handle field reorder\n    if (activeData?.type === \"field\" && active.id !== over.id) {\n      const oldIndex = fields.findIndex((f) => f.id === active.id);\n      const newIndex = fields.findIndex((f) => f.id === over.id);\n\n      if (oldIndex !== -1 && newIndex !== -1) {\n        const newFields = arrayMove(fields, oldIndex, newIndex);\n        setFields(newFields);\n        notifyChange(newFields);\n      }\n    }\n  };\n\n  // Update field props (with optional ID change and step group)\n  const handleUpdateField = useCallback(\n    (id: string, props: Partial<FormBuilderFieldProps>, newId?: string, stepGroup?: number) => {\n      // Validate that the new ID doesn't already exist on another field\n      if (newId && newId !== id) {\n        const idExists = fields.some((f) => f.id === newId && f.id !== id);\n        if (idExists) {\n          // Reject the update - duplicate ID would cause data loss\n          console.warn(`Cannot rename field \"${id}\" to \"${newId}\": a field with that ID already exists`);\n          return;\n        }\n      }\n      \n      const newFields = fields.map((f) => {\n        if (f.id !== id) return f;\n        const updated: FormBuilderField = { \n          ...f, \n          id: newId || f.id, \n          props: { ...f.props, ...props } \n        };\n        // Only update stepGroup if explicitly provided (not undefined)\n        if (stepGroup !== undefined) {\n          updated.stepGroup = stepGroup;\n        }\n        return updated;\n      });\n      setFields(newFields);\n      notifyChange(newFields);\n    },\n    [fields, notifyChange]\n  );\n\n  // Open edit dialog for a field\n  const handleEditField = useCallback((id: string) => {\n    setEditDialogFieldId(id);\n  }, []);\n\n  // Delete field\n  const handleDeleteField = useCallback(\n    (id: string) => {\n      const newFields = fields.filter((f) => f.id !== id);\n      setFields(newFields);\n      notifyChange(newFields);\n    },\n    [fields, notifyChange]\n  );\n\n  // Open nested field editor for object/array fields\n  const handleConfigureNested = useCallback((id: string) => {\n    setNestedEditorFieldId(id);\n  }, []);\n\n  // Save nested fields (children for object, itemTemplate for array)\n  const handleSaveNestedFields = useCallback(\n    (fieldId: string, nestedFields: FormBuilderField[]) => {\n      const newFields = fields.map((f) => {\n        if (f.id !== fieldId) return f;\n        \n        if (f.type === \"object\") {\n          return { ...f, children: nestedFields };\n        } else if (f.type === \"array\") {\n          return { ...f, itemTemplate: nestedFields };\n        }\n        return f;\n      });\n      setFields(newFields);\n      notifyChange(newFields);\n    },\n    [fields, notifyChange]\n  );\n\n  // ============================================================================\n  // STEP HANDLERS\n  // ============================================================================\n\n  // Add a new step\n  const handleAddStep = useCallback(() => {\n    const newStep = createStep(steps.length);\n    const newSteps = [...steps, newStep];\n    \n    // If this is the second step, we need to assign all existing fields to step 0\n    if (steps.length === 1) {\n      const updatedFields = fields.map((f) => ({ ...f, stepGroup: 0 }));\n      setFields(updatedFields);\n      setSteps(newSteps);\n      notifyChange(updatedFields, newSteps);\n    } else if (steps.length === 0) {\n      // First step - create two steps (Step 1 and Step 2)\n      const firstStep = createStep(0);\n      const secondStep = createStep(1);\n      const bothSteps = [firstStep, secondStep];\n      const updatedFields = fields.map((f) => ({ ...f, stepGroup: 0 }));\n      setFields(updatedFields);\n      setSteps(bothSteps);\n      notifyChange(updatedFields, bothSteps);\n    } else {\n      setSteps(newSteps);\n      notifyChange(fields, newSteps);\n    }\n  }, [steps, fields, notifyChange]);\n\n  // Delete a step\n  const handleDeleteStep = useCallback(\n    (index: number) => {\n      // Filter out fields belonging to the deleted step\n      const fieldsWithoutDeleted = fields.filter((f) => f.stepGroup !== index);\n\n      if (steps.length <= 2) {\n        // Going from 2 steps to single-step mode\n        // Remove stepGroup from remaining fields\n        const updatedFields = fieldsWithoutDeleted.map((f) => {\n          const { stepGroup: _, ...rest } = f;\n          return rest;\n        });\n        setFields(updatedFields);\n        setSteps([]);\n        setActiveStepIndex(0);\n        notifyChange(updatedFields, []);\n      } else {\n        // Remove the step\n        const newSteps = steps.filter((_, i) => i !== index);\n\n        // Decrement stepGroup for fields after the deleted step\n        const updatedFields = fieldsWithoutDeleted.map((f) => {\n          if (f.stepGroup !== undefined && f.stepGroup > index) {\n            return { ...f, stepGroup: f.stepGroup - 1 };\n          }\n          return f;\n        });\n\n        setFields(updatedFields);\n        setSteps(newSteps);\n        // Adjust active step if needed\n        if (activeStepIndex >= newSteps.length) {\n          setActiveStepIndex(newSteps.length - 1);\n        }\n        notifyChange(updatedFields, newSteps);\n      }\n    },\n    [steps, fields, activeStepIndex, notifyChange]\n  );\n\n  // Rename a step\n  const handleRenameStep = useCallback(\n    (index: number, newTitle: string) => {\n      const newSteps = steps.map((step, i) =>\n        i === index ? { ...step, title: newTitle } : step\n      );\n      setSteps(newSteps);\n      notifyChange(fields, newSteps);\n    },\n    [steps, fields, notifyChange]\n  );\n\n  // Get edit dialog field and its component\n  const editDialogField = fields.find((f) => f.id === editDialogFieldId) || null;\n  const editDialogComponent = editDialogField\n    ? getComponentByType(editDialogField.type, components) || null\n    : null;\n\n  // Get nested editor field\n  const nestedEditorField = fields.find((f) => f.id === nestedEditorFieldId) || null;\n\n  return (\n    <div className={cn(\"flex flex-col lg:h-full\", className)}>\n      <DndContext\n        id={dndContextId}\n        sensors={sensors}\n        collisionDetection={closestCenter}\n        onDragStart={handleDragStart}\n        onDragEnd={handleDragEnd}\n      >\n        {/* Mobile: stack vertically and allow page scroll. Desktop: horizontal layout with overflow */}\n        <div className=\"flex-1 flex flex-col lg:flex-row lg:overflow-hidden\">\n          {/* Palette */}\n          <div className=\"w-full lg:w-64 p-4 border-b lg:border-b-0 lg:border-r lg:overflow-auto shrink-0\">\n            <Palette components={components} />\n          </div>\n\n          {/* Canvas */}\n          <div className=\"flex-1 p-4 lg:overflow-auto min-h-[300px]\">\n            <Canvas\n              fields={fields}\n              components={components}\n              onEditField={handleEditField}\n              onDeleteField={handleDeleteField}\n              onConfigureNested={handleConfigureNested}\n              isDraggingFromPalette={activeDragData?.type === \"palette\"}\n              steps={steps}\n              activeStepIndex={activeStepIndex}\n              onActiveStepChange={setActiveStepIndex}\n              onAddStep={handleAddStep}\n              onDeleteStep={handleDeleteStep}\n              onRenameStep={handleRenameStep}\n            />\n          </div>\n\n          {/* Right Panel with Tabs */}\n          <div className=\"w-full flex-1 lg:w-96 border-t lg:border-t-0 lg:border-l lg:overflow-auto min-h-[300px]\">\n            <Tabs defaultValue=\"preview\" className=\"h-full flex flex-col\">\n              <div className=\"p-4 border-b\">\n                <TabsList className=\"w-full\">\n                  <TabsTrigger value=\"preview\" className=\"flex-1\">\n                    Preview\n                  </TabsTrigger>\n                  <TabsTrigger value=\"schema\" className=\"flex-1\">\n                    JSON Schema\n                  </TabsTrigger>\n                </TabsList>\n              </div>\n              <TabsContent value=\"preview\" className=\"flex-1 m-0 lg:overflow-auto\">\n                <FormPreview schema={currentSchema} fieldComponents={fieldComponents} defaultValues={defaultValues} />\n              </TabsContent>\n              <TabsContent value=\"schema\" className=\"flex-1 m-0 p-4 lg:overflow-auto\">\n                <div className=\"rounded-lg border bg-muted/50 p-4\">\n                  <pre className=\"text-sm overflow-auto whitespace-pre-wrap\">\n                    {JSON.stringify(currentSchema, null, 2)}\n                  </pre>\n                </div>\n              </TabsContent>\n            </Tabs>\n          </div>\n        </div>\n\n        {/* Drag Overlay */}\n        <DragOverlay dropAnimation={null}>\n          {activeDragData?.type === \"palette\" && activeDragData.component && (\n            <PaletteDragOverlay component={activeDragData.component} />\n          )}\n          {activeDragData?.type === \"field\" && activeDragData.field && (\n            <FieldDragOverlay\n              field={activeDragData.field}\n              component={activeDragData.component}\n            />\n          )}\n        </DragOverlay>\n      </DndContext>\n\n      {/* Edit Field Dialog */}\n      <EditFieldDialog\n        open={editDialogFieldId !== null}\n        onOpenChange={(open) => !open && setEditDialogFieldId(null)}\n        field={editDialogField}\n        component={editDialogComponent}\n        onUpdate={handleUpdateField}\n        steps={steps}\n        allFieldIds={fields.map((f) => f.id)}\n      />\n\n      {/* Nested Field Editor Dialog */}\n      <NestedFieldEditorDialog\n        open={nestedEditorFieldId !== null}\n        onOpenChange={(open) => !open && setNestedEditorFieldId(null)}\n        field={nestedEditorField}\n        components={components}\n        onSave={handleSaveNestedFields}\n      />\n    </div>\n  );\n}\n\nexport default FormBuilder;\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/nested-field-editor-dialog.tsx",
      "content": "\"use client\";\n\nimport { useCallback, useId, useMemo, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport {\n  DndContext,\n  DragOverlay,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  TouchSensor,\n  useSensor,\n  useSensors,\n  type DragEndEvent,\n  type DragStartEvent,\n  type UniqueIdentifier,\n} from \"@dnd-kit/core\";\nimport { snapCenterToCursor } from \"@dnd-kit/modifiers\";\nimport {\n  arrayMove,\n  sortableKeyboardCoordinates,\n} from \"@dnd-kit/sortable\";\nimport { FolderOpen, List } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Palette, PaletteDragOverlay } from \"./palette\";\nimport { Canvas } from \"./canvas\";\nimport { EditFieldDialog } from \"./edit-field-dialog\";\nimport { FieldDragOverlay } from \"./sortable-field\";\nimport { getComponentByType } from \"./components\";\nimport { generateFieldId } from \"./schema-utils\";\nimport type {\n  FormBuilderComponentDefinition,\n  FormBuilderField,\n  FormBuilderFieldProps,\n  DragData,\n  PaletteDragData,\n} from \"./types\";\n\ninterface NestedFieldEditorDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  /** The parent field being edited (object or array) */\n  field: FormBuilderField | null;\n  /** Available component definitions */\n  components: FormBuilderComponentDefinition[];\n  /** Callback when the nested fields are saved */\n  onSave: (fieldId: string, nestedFields: FormBuilderField[]) => void;\n}\n\nexport function NestedFieldEditorDialog({\n  open,\n  onOpenChange,\n  field,\n  components,\n  onSave,\n}: NestedFieldEditorDialogProps) {\n  // Stable ID for nested DndContext\n  const dndContextId = useId();\n\n  // Get the nested fields based on field type\n  const initialFields = useMemo(() => {\n    if (!field) return [];\n    if (field.type === \"object\") return field.children || [];\n    if (field.type === \"array\") return field.itemTemplate || [];\n    return [];\n  }, [field]);\n\n  // Local state for editing\n  const [nestedFields, setNestedFields] = useState<FormBuilderField[]>(initialFields);\n  const [activeId, setActiveId] = useState<UniqueIdentifier | null>(null);\n  const [editDialogFieldId, setEditDialogFieldId] = useState<string | null>(null);\n\n  // Reset local state when field changes or dialog opens\n  const [prevField, setPrevField] = useState(field);\n  const [prevOpen, setPrevOpen] = useState(open);\n  if (prevField !== field || (open && !prevOpen)) {\n    setPrevField(field);\n    setPrevOpen(open);\n    setNestedFields(initialFields);\n    setEditDialogFieldId(null);\n  }\n  if (prevOpen !== open) {\n    setPrevOpen(open);\n  }\n\n  // Sensors for dnd-kit\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: { distance: 8 },\n    }),\n    useSensor(TouchSensor, {\n      activationConstraint: { distance: 8 },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  // Determine what's being dragged\n  const activeDragData = useMemo(() => {\n    if (!activeId) return null;\n\n    const idStr = String(activeId);\n\n    // Check if it's a palette item\n    if (idStr.startsWith(\"palette-\")) {\n      const componentType = idStr.replace(\"palette-\", \"\");\n      return {\n        type: \"palette\",\n        componentType,\n        component: getComponentByType(componentType, components),\n      };\n    }\n\n    // Otherwise it's a field\n    const nestedField = nestedFields.find((f) => f.id === idStr);\n    if (nestedField) {\n      return {\n        type: \"field\",\n        field: nestedField,\n        component: getComponentByType(nestedField.type, components),\n      };\n    }\n\n    return null;\n  }, [activeId, nestedFields, components]);\n\n  // Handle drag start\n  const handleDragStart = (event: DragStartEvent) => {\n    setActiveId(event.active.id);\n  };\n\n  // Handle drag end\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event;\n    setActiveId(null);\n\n    if (!over) return;\n\n    const activeData = active.data.current as DragData | undefined;\n\n    // Handle palette item drop\n    if (activeData?.type === \"palette\") {\n      const { componentType } = activeData as PaletteDragData;\n      const component = getComponentByType(componentType, components);\n\n      if (component) {\n        const newField: FormBuilderField = {\n          id: generateFieldId(componentType),\n          type: componentType,\n          props: {\n            label: component.defaultProps.label || component.label,\n            ...component.defaultProps,\n          },\n        };\n\n        // Determine insertion index\n        let insertIndex = nestedFields.length;\n        const overId = String(over.id);\n\n        if (overId === \"drop-zone-start\") {\n          insertIndex = 0;\n        } else if (overId.startsWith(\"drop-zone-\")) {\n          const fieldId = overId.replace(\"drop-zone-\", \"\");\n          const overIndex = nestedFields.findIndex((f) => f.id === fieldId);\n          if (overIndex !== -1) {\n            insertIndex = overIndex + 1;\n          }\n        } else if (overId !== \"canvas\") {\n          const overIndex = nestedFields.findIndex((f) => f.id === overId);\n          if (overIndex !== -1) {\n            insertIndex = overIndex + 1;\n          }\n        }\n\n        const newFields = [...nestedFields];\n        newFields.splice(insertIndex, 0, newField);\n        setNestedFields(newFields);\n      }\n      return;\n    }\n\n    // Handle field reorder\n    if (activeData?.type === \"field\" && active.id !== over.id) {\n      const oldIndex = nestedFields.findIndex((f) => f.id === active.id);\n      const newIndex = nestedFields.findIndex((f) => f.id === over.id);\n\n      if (oldIndex !== -1 && newIndex !== -1) {\n        setNestedFields(arrayMove(nestedFields, oldIndex, newIndex));\n      }\n    }\n  };\n\n  // Handle delete field\n  const handleDeleteField = useCallback((id: string) => {\n    setNestedFields((fields) => fields.filter((f) => f.id !== id));\n  }, []);\n\n  // Handle edit field - open the edit dialog\n  const handleEditField = useCallback((id: string) => {\n    setEditDialogFieldId(id);\n  }, []);\n\n  // Handle update field from edit dialog\n  const handleUpdateField = useCallback(\n    (id: string, props: Partial<FormBuilderFieldProps>, newId?: string) => {\n      // Validate that the new ID doesn't already exist on another field\n      if (newId && newId !== id) {\n        const idExists = nestedFields.some((f) => f.id === newId && f.id !== id);\n        if (idExists) {\n          console.warn(`Cannot rename field \"${id}\" to \"${newId}\": a field with that ID already exists`);\n          return;\n        }\n      }\n\n      setNestedFields((fields) =>\n        fields.map((f) => {\n          if (f.id !== id) return f;\n          return {\n            ...f,\n            id: newId || f.id,\n            props: { ...f.props, ...props },\n          };\n        })\n      );\n    },\n    [nestedFields]\n  );\n\n  // Handle save\n  const handleSave = useCallback(() => {\n    if (!field) return;\n    onSave(field.id, nestedFields);\n    onOpenChange(false);\n  }, [field, nestedFields, onSave, onOpenChange]);\n\n  if (!field) return null;\n\n  const isObjectField = field.type === \"object\";\n  const Icon = isObjectField ? FolderOpen : List;\n  const fieldTypeLabel = isObjectField ? \"Field Group\" : \"Repeating Group\";\n  const nestedLabel = isObjectField ? \"nested fields\" : \"item fields\";\n\n  // Get edit dialog field and its component\n  const editDialogField = nestedFields.find((f) => f.id === editDialogFieldId) || null;\n  const editDialogComponent = editDialogField\n    ? getComponentByType(editDialogField.type, components) || null\n    : null;\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-6xl! max-h-[90vh] overflow-hidden flex flex-col\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            <Icon className=\"h-5 w-5 text-muted-foreground\" />\n            Configure {fieldTypeLabel}: {field.props.label}\n          </DialogTitle>\n          <DialogDescription>\n            Add and arrange the {nestedLabel} for this {fieldTypeLabel.toLowerCase()}.\n            {isObjectField\n              ? \" These fields will be grouped together.\"\n              : \" Each item in the array will have these fields.\"}\n          </DialogDescription>\n        </DialogHeader>\n\n        <div className=\"flex-1 overflow-hidden\">\n          <DndContext\n            id={dndContextId}\n            sensors={sensors}\n            collisionDetection={closestCenter}\n            onDragStart={handleDragStart}\n            onDragEnd={handleDragEnd}\n          >\n            <div className=\"flex h-[50vh] gap-4\">\n              {/* Palette */}\n              <div className=\"w-48 overflow-auto shrink-0 border-r pr-4\">\n                <Palette components={components} />\n              </div>\n\n              {/* Canvas */}\n              <div className=\"flex-1 overflow-auto\">\n                <Canvas\n                  fields={nestedFields}\n                  components={components}\n                  onEditField={handleEditField}\n                  onDeleteField={handleDeleteField}\n                  isDraggingFromPalette={activeDragData?.type === \"palette\"}\n                  // Nested fields don't support steps - hide step controls entirely\n                  steps={[]}\n                  activeStepIndex={0}\n                  onActiveStepChange={() => {}}\n                  onAddStep={() => {}}\n                  onDeleteStep={() => {}}\n                  onRenameStep={() => {}}\n                  hideStepControls\n                />\n              </div>\n            </div>\n\n            {/* Drag Overlay - rendered in portal to escape dialog's transform context */}\n            {typeof document !== \"undefined\" &&\n              createPortal(\n                <DragOverlay dropAnimation={null} modifiers={[snapCenterToCursor]}>\n                  {activeDragData?.type === \"palette\" && activeDragData.component && (\n                    <PaletteDragOverlay component={activeDragData.component} />\n                  )}\n                  {activeDragData?.type === \"field\" && activeDragData.field && (\n                    <FieldDragOverlay\n                      field={activeDragData.field}\n                      component={activeDragData.component}\n                    />\n                  )}\n                </DragOverlay>,\n                document.body\n              )}\n          </DndContext>\n        </div>\n\n        <DialogFooter className=\"border-t pt-4\">\n          <div className=\"flex items-center gap-2 text-sm text-muted-foreground mr-auto\">\n            {nestedFields.length} {nestedFields.length === 1 ? \"field\" : \"fields\"}\n          </div>\n          <Button variant=\"outline\" onClick={() => onOpenChange(false)}>\n            Cancel\n          </Button>\n          <Button onClick={handleSave}>Save Fields</Button>\n        </DialogFooter>\n      </DialogContent>\n\n      {/* Edit Field Dialog for nested fields */}\n      <EditFieldDialog\n        open={editDialogFieldId !== null}\n        onOpenChange={(open) => !open && setEditDialogFieldId(null)}\n        field={editDialogField}\n        component={editDialogComponent}\n        onUpdate={handleUpdateField}\n        steps={[]}\n        allFieldIds={nestedFields.map((f) => f.id)}\n      />\n    </Dialog>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/palette.tsx",
      "content": "\"use client\";\n\nimport { useDraggable } from \"@dnd-kit/core\";\nimport { cn } from \"@/lib/utils\";\nimport type { FormBuilderComponentDefinition, PaletteDragData } from \"./types\";\n\ninterface PaletteItemProps {\n  component: FormBuilderComponentDefinition;\n}\n\nfunction PaletteItem({ component }: PaletteItemProps) {\n  const { attributes, listeners, setNodeRef, isDragging } = useDraggable({\n    id: `palette-${component.type}`,\n    data: {\n      type: \"palette\",\n      componentType: component.type,\n    } satisfies PaletteDragData,\n  });\n\n  const Icon = component.icon as React.ComponentType<{ className?: string }>;\n\n  return (\n    <div\n      ref={setNodeRef}\n      {...listeners}\n      {...attributes}\n      className={cn(\n        \"flex items-center gap-3 p-3 rounded-lg border bg-card cursor-grab active:cursor-grabbing\",\n        \"hover:bg-accent hover:border-accent-foreground/20 transition-colors\",\n        \"touch-none select-none\",\n        isDragging && \"opacity-50\"\n      )}\n    >\n      {Icon && <Icon className=\"h-4 w-4 text-muted-foreground shrink-0\" />}\n      <span className=\"text-sm font-medium\">{component.label}</span>\n    </div>\n  );\n}\n\ninterface PaletteProps {\n  components: FormBuilderComponentDefinition[];\n  className?: string;\n}\n\nexport function Palette({ components, className }: PaletteProps) {\n  return (\n    <div className={cn(\"flex flex-col gap-2\", className)} data-testid=\"form-builder-palette\">\n      <h3 className=\"text-sm font-semibold text-muted-foreground mb-2\">\n        Components\n      </h3>\n      <div className=\"flex flex-row flex-wrap lg:flex-col gap-2\">\n        {components.map((component) => (\n          <PaletteItem key={component.type} component={component} />\n        ))}\n      </div>\n    </div>\n  );\n}\n\ninterface PaletteDragOverlayProps {\n  component: FormBuilderComponentDefinition | null;\n}\n\nexport function PaletteDragOverlay({ component }: PaletteDragOverlayProps) {\n  if (!component) return null;\n\n  const Icon = component.icon as React.ComponentType<{ className?: string }>;\n\n  return (\n    <div className=\"flex items-center gap-3 p-3 rounded-lg border bg-card shadow-lg cursor-grabbing\">\n      {Icon && <Icon className=\"h-4 w-4 text-muted-foreground shrink-0\" />}\n      <span className=\"text-sm font-medium\">{component.label}</span>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/property-panel.tsx",
      "content": "\"use client\";\n\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport AutoForm from \"@/components/ui/auto-form\";\nimport { cn } from \"@/lib/utils\";\nimport { buildFieldConfigFromJsonSchema } from \"@/components/ui/auto-form/utils\";\nimport type { FormBuilderField, FormBuilderComponentDefinition, FormBuilderFieldProps } from \"./types\";\n\ninterface PropertyPanelProps {\n  field: FormBuilderField | null;\n  component: FormBuilderComponentDefinition | null;\n  onUpdate: (props: Partial<FormBuilderFieldProps>) => void;\n  className?: string;\n}\n\nexport function PropertyPanel({\n  field,\n  component,\n  onUpdate,\n  className,\n}: PropertyPanelProps) {\n  // Track form values locally for controlled updates\n  const [formKey, setFormKey] = useState(0);\n\n  // Reset form when field changes\n  useEffect(() => {\n    setFormKey((k) => k + 1);\n  }, [field?.id]);\n\n  // Convert field props to form values\n  const formValues = useMemo(() => {\n    if (!field) return undefined;\n\n    // Handle special case for options (array to string)\n    const values: Record<string, unknown> = { ...field.props };\n    if (Array.isArray(values.options)) {\n      values.options = (values.options as string[]).join(\"\\n\");\n    }\n\n    return values;\n  }, [field]);\n\n  // Handle form value changes\n  const handleValuesChange = useCallback(\n    (values: Record<string, unknown>) => {\n      if (!field) return;\n\n      // Handle special case for options (string to array)\n      const props: Partial<FormBuilderFieldProps> = { ...values };\n      if (typeof props.options === \"string\") {\n        props.options = (props.options as string)\n          .split(\"\\n\")\n          .map((s) => s.trim())\n          .filter(Boolean);\n      }\n\n      onUpdate(props);\n    },\n    [field, onUpdate]\n  );\n\n  if (!field || !component) {\n    return (\n      <div className={cn(\"p-4\", className)}>\n        <h3 className=\"text-sm font-semibold text-muted-foreground mb-4\">\n          Properties\n        </h3>\n        <div className=\"flex items-center justify-center h-32 text-muted-foreground text-sm\">\n          Select a field to edit its properties\n        </div>\n      </div>\n    );\n  }\n\n  const Icon = component.icon as React.ComponentType<{ className?: string }>;\n\n  // Build field config from the schema metadata\n  const jsonSchema = component.propertiesSchema.toJSONSchema() as Record<string, unknown>;\n  const fieldConfig = buildFieldConfigFromJsonSchema(jsonSchema);\n\n  return (\n    <div className={cn(\"p-4\", className)}>\n      <div className=\"flex items-center gap-2 mb-4\">\n        {Icon && <Icon className=\"h-4 w-4 text-muted-foreground\" />}\n        <h3 className=\"text-sm font-semibold\">{component.label}</h3>\n      </div>\n\n      <AutoForm\n        key={formKey}\n        formSchema={component.propertiesSchema}\n        values={formValues}\n        onValuesChange={handleValuesChange}\n        fieldConfig={fieldConfig}\n        className=\"space-y-4\"\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/schema-utils.ts",
      "content": "import type {\n  FormBuilderComponentDefinition,\n  FormBuilderField,\n  FormStep,\n  JSONSchema,\n  JSONSchemaProperty,\n} from \"./types\";\n\n/**\n * Helper to convert fields to JSON Schema properties (recursive)\n * @param includeStepGroup - Whether to include stepGroup in the schema (only for multi-step forms)\n */\nfunction fieldsToProperties(\n  fields: FormBuilderField[],\n  components: FormBuilderComponentDefinition[],\n  includeStepGroup: boolean = false\n): Record<string, JSONSchemaProperty> {\n  const properties: Record<string, JSONSchemaProperty> = {};\n\n  for (const field of fields) {\n    const component = components.find((c) => c.type === field.type);\n    if (!component) {\n      console.warn(`Unknown component type: ${field.type}`);\n      continue;\n    }\n\n    const isRequired = field.props.required ?? false;\n    const schemaProp = component.toJSONSchema(field.props, isRequired);\n\n    // Add stepGroup if we're in multi-step mode and field has a stepGroup\n    if (includeStepGroup && field.stepGroup !== undefined) {\n      schemaProp.stepGroup = field.stepGroup;\n    }\n\n    // Handle nested object fields\n    if (field.type === \"object\" && field.children && field.children.length > 0) {\n      schemaProp.properties = fieldsToProperties(field.children, components, false);\n      const childRequired = field.children\n        .filter((child) => child.props.required)\n        .map((child) => child.id);\n      if (childRequired.length > 0) {\n        schemaProp.required = childRequired;\n      }\n    }\n\n    // Handle nested array fields\n    if (field.type === \"array\" && field.itemTemplate && field.itemTemplate.length > 0) {\n      schemaProp.items = {\n        type: \"object\",\n        properties: fieldsToProperties(field.itemTemplate, components, false),\n      };\n      const itemRequired = field.itemTemplate\n        .filter((item) => item.props.required)\n        .map((item) => item.id);\n      if (itemRequired.length > 0) {\n        schemaProp.items.required = itemRequired;\n      }\n    }\n\n    properties[field.id] = schemaProp;\n  }\n\n  return properties;\n}\n\n/**\n * Helper to get required field IDs from a list of fields\n */\nfunction getRequiredFieldIds(fields: FormBuilderField[]): string[] {\n  return fields.filter((f) => f.props.required).map((f) => f.id);\n}\n\n/**\n * Convert internal fields to JSON Schema\n * @param steps - Optional steps array for multi-step forms\n */\nexport function fieldsToJSONSchema(\n  fields: FormBuilderField[],\n  components: FormBuilderComponentDefinition[],\n  steps?: FormStep[]\n): JSONSchema {\n  // Include stepGroup in properties only if we have multiple steps\n  const hasMultipleSteps = steps && steps.length > 1;\n  const properties = fieldsToProperties(fields, components, hasMultipleSteps);\n  const required = getRequiredFieldIds(fields);\n\n  return {\n    type: \"object\",\n    properties,\n    ...(required.length > 0 ? { required } : {}),\n    // Only include steps if there are multiple steps\n    ...(hasMultipleSteps ? { steps } : {}),\n  };\n}\n\n/**\n * Helper to parse JSON Schema properties into fields (recursive)\n */\nfunction propertiesToFields(\n  properties: Record<string, JSONSchemaProperty>,\n  requiredSet: Set<string>,\n  components: FormBuilderComponentDefinition[]\n): FormBuilderField[] {\n  const fields: FormBuilderField[] = [];\n\n  for (const [key, prop] of Object.entries(properties)) {\n    const isRequired = requiredSet.has(key);\n    let field: FormBuilderField | null = null;\n\n    // Try each component's fromJSONSchema in order\n    // Components are ordered by specificity (more specific first)\n    for (const component of components) {\n      field = component.fromJSONSchema(prop, key, isRequired);\n      if (field) {\n        break;\n      }\n    }\n\n    if (field) {\n      // Extract stepGroup from the property if present\n      if (prop.stepGroup !== undefined) {\n        field.stepGroup = prop.stepGroup;\n      }\n\n      // Handle nested object fields\n      if (field.type === \"object\" && prop.properties) {\n        const childRequiredSet = new Set(prop.required || []);\n        field.children = propertiesToFields(prop.properties, childRequiredSet, components);\n      }\n\n      // Handle nested array fields\n      if (field.type === \"array\" && prop.items?.properties) {\n        const itemRequiredSet = new Set(prop.items.required || []);\n        field.itemTemplate = propertiesToFields(prop.items.properties, itemRequiredSet, components);\n      }\n\n      fields.push(field);\n    } else {\n      // Fallback: create a generic text field for unknown types\n      console.warn(`Could not parse JSON Schema property: ${key}`, prop);\n      fields.push({\n        id: key,\n        type: \"text\",\n        props: {\n          label: prop.title || key,\n          description: prop.description,\n          placeholder: prop.placeholder,\n          required: isRequired,\n        },\n        // Include stepGroup even for fallback fields\n        ...(prop.stepGroup !== undefined ? { stepGroup: prop.stepGroup } : {}),\n      });\n    }\n  }\n\n  return fields;\n}\n\n/**\n * Result of parsing a JSON Schema\n */\nexport interface ParsedSchema {\n  fields: FormBuilderField[];\n  steps: FormStep[];\n}\n\n/**\n * Convert JSON Schema to internal fields and extract steps\n */\nexport function jsonSchemaToFieldsAndSteps(\n  schema: JSONSchema | null | undefined,\n  components: FormBuilderComponentDefinition[]\n): ParsedSchema {\n  if (!schema || !schema.properties) {\n    return { fields: [], steps: [] };\n  }\n\n  const requiredSet = new Set(schema.required || []);\n  const fields = propertiesToFields(schema.properties, requiredSet, components);\n  const steps = schema.steps || [];\n\n  return { fields, steps };\n}\n\n/**\n * Convert JSON Schema to internal fields\n * @deprecated Use jsonSchemaToFieldsAndSteps for multi-step support\n */\nexport function jsonSchemaToFields(\n  schema: JSONSchema | null | undefined,\n  components: FormBuilderComponentDefinition[]\n): FormBuilderField[] {\n  return jsonSchemaToFieldsAndSteps(schema, components).fields;\n}\n\n/**\n * Generate a unique field ID\n */\nexport function generateFieldId(prefix: string = \"field\"): string {\n  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Sanitize a field ID to be a valid JSON Schema property key\n */\nexport function sanitizeFieldId(id: string): string {\n  return id.replace(/[^a-zA-Z0-9_]/g, \"_\").replace(/^[0-9]/, \"_$&\");\n}\n\n/**\n * Generate a unique step ID\n */\nexport function generateStepId(): string {\n  return `step_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Create a new step with default title\n */\nexport function createStep(index: number): FormStep {\n  return {\n    id: generateStepId(),\n    title: `Step ${index + 1}`,\n  };\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/sortable-field.tsx",
      "content": "\"use client\";\n\nimport { useSortable } from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { GripVertical, Pencil, Trash2, Settings2 } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport type { FormBuilderField, FormBuilderComponentDefinition, FieldDragData } from \"./types\";\n\ninterface SortableFieldProps {\n  field: FormBuilderField;\n  index: number;\n  component: FormBuilderComponentDefinition | undefined;\n  onEdit: () => void;\n  onDelete: () => void;\n  /** Callback to configure nested fields for object/array types */\n  onConfigureNested?: () => void;\n}\n\nexport function SortableField({\n  field,\n  index,\n  component,\n  onEdit,\n  onDelete,\n  onConfigureNested,\n}: SortableFieldProps) {\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({\n    id: field.id,\n    data: {\n      type: \"field\",\n      fieldId: field.id,\n      index,\n    } satisfies FieldDragData,\n  });\n\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n  };\n\n  const Icon = component?.icon as React.ComponentType<{ className?: string }> | undefined;\n  \n  // Check if this is a container field (object or array)\n  const isContainerField = field.type === \"object\" || field.type === \"array\";\n  const nestedFieldCount = field.type === \"object\" \n    ? (field.children?.length || 0)\n    : (field.itemTemplate?.length || 0);\n\n  return (\n    <div\n      ref={setNodeRef}\n      style={style}\n      className={cn(\n        \"group flex items-center gap-2 p-3 rounded-lg border bg-card\",\n        \"transition-all duration-200\",\n        isDragging && \"opacity-50 shadow-lg z-50\",\n        !isDragging && \"hover:border-muted-foreground/30\"\n      )}\n    >\n      {/* Drag Handle */}\n      <div\n        {...attributes}\n        {...listeners}\n        className={cn(\n          \"flex items-center justify-center p-1 rounded cursor-grab active:cursor-grabbing\",\n          \"hover:bg-muted touch-none\",\n          \"min-w-[44px] min-h-[44px] -m-1\"\n        )}\n        onClick={(e) => e.stopPropagation()}\n      >\n        <GripVertical className=\"h-4 w-4 text-muted-foreground\" />\n      </div>\n\n      {/* Field Content */}\n      <div className=\"flex-1 min-w-0\">\n        <div className=\"flex items-center gap-2\">\n          {Icon && <Icon className=\"h-4 w-4 text-muted-foreground shrink-0\" />}\n          <span className=\"font-medium truncate\">{field.props.label}</span>\n          {field.props.required && (\n            <span className=\"text-destructive text-sm\">*</span>\n          )}\n          {isContainerField && (\n            <span className=\"text-xs bg-muted px-1.5 py-0.5 rounded text-muted-foreground\">\n              {nestedFieldCount} {nestedFieldCount === 1 ? \"field\" : \"fields\"}\n            </span>\n          )}\n        </div>\n        {field.props.description && (\n          <p className=\"text-sm text-muted-foreground truncate mt-0.5\">\n            {field.props.description}\n          </p>\n        )}\n        <p className=\"text-xs text-muted-foreground/60 mt-1\">\n          {component?.label || field.type}\n        </p>\n      </div>\n\n      {/* Action Buttons */}\n      <div className=\"flex items-center gap-1\">\n        {/* Configure Nested Fields button for container types */}\n        {isContainerField && onConfigureNested && (\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            className={cn(\n              \"h-8 w-8 text-muted-foreground hover:text-primary\",\n              \"opacity-0 group-hover:opacity-100 transition-opacity\",\n              \"min-w-[44px] min-h-[44px]\"\n            )}\n            onClick={(e) => {\n              e.stopPropagation();\n              onConfigureNested();\n            }}\n            title=\"Configure nested fields\"\n          >\n            <Settings2 className=\"h-4 w-4\" />\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          className={cn(\n            \"h-8 w-8 text-muted-foreground hover:text-primary\",\n            \"opacity-0 group-hover:opacity-100 transition-opacity\",\n            \"min-w-[44px] min-h-[44px]\"\n          )}\n          onClick={(e) => {\n            e.stopPropagation();\n            onEdit();\n          }}\n        >\n          <Pencil className=\"h-4 w-4\" />\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          className={cn(\n            \"h-8 w-8 text-muted-foreground hover:text-destructive\",\n            \"opacity-0 group-hover:opacity-100 transition-opacity\",\n            \"min-w-[44px] min-h-[44px]\"\n          )}\n          onClick={(e) => {\n            e.stopPropagation();\n            onDelete();\n          }}\n        >\n          <Trash2 className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </div>\n  );\n}\n\ninterface FieldDragOverlayProps {\n  field: FormBuilderField;\n  component: FormBuilderComponentDefinition | undefined;\n}\n\nexport function FieldDragOverlay({ field, component }: FieldDragOverlayProps) {\n  const Icon = component?.icon as React.ComponentType<{ className?: string }> | undefined;\n\n  return (\n    <div className=\"flex items-center gap-2 p-3 rounded-lg border bg-card shadow-lg cursor-grabbing\">\n      <div className=\"p-1\">\n        <GripVertical className=\"h-4 w-4 text-muted-foreground\" />\n      </div>\n      <div className=\"flex-1 min-w-0\">\n        <div className=\"flex items-center gap-2\">\n          {Icon && <Icon className=\"h-4 w-4 text-muted-foreground shrink-0\" />}\n          <span className=\"font-medium truncate\">{field.props.label}</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/step-tabs.tsx",
      "content": "\"use client\";\n\nimport { useState } from \"react\";\nimport { Plus, Pencil, Trash2, Check, X } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport type { FormStep } from \"./types\";\n\ninterface StepTabsProps {\n  steps: FormStep[];\n  activeStepIndex: number;\n  onActiveStepChange: (index: number) => void;\n  onAddStep: () => void;\n  onDeleteStep: (index: number) => void;\n  onRenameStep: (index: number, newTitle: string) => void;\n  className?: string;\n  /** Hide all step controls (used in nested field editor) */\n  hideStepControls?: boolean;\n}\n\nexport function StepTabs({\n  steps,\n  activeStepIndex,\n  onActiveStepChange,\n  onAddStep,\n  onDeleteStep,\n  onRenameStep,\n  className,\n  hideStepControls,\n}: StepTabsProps) {\n  const [editingIndex, setEditingIndex] = useState<number | null>(null);\n  const [editValue, setEditValue] = useState(\"\");\n\n  const handleStartEdit = (index: number, currentTitle: string) => {\n    setEditingIndex(index);\n    setEditValue(currentTitle);\n  };\n\n  const handleConfirmEdit = () => {\n    if (editingIndex !== null && editValue.trim()) {\n      onRenameStep(editingIndex, editValue.trim());\n    }\n    setEditingIndex(null);\n    setEditValue(\"\");\n  };\n\n  const handleCancelEdit = () => {\n    setEditingIndex(null);\n    setEditValue(\"\");\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Enter\") {\n      handleConfirmEdit();\n    } else if (e.key === \"Escape\") {\n      handleCancelEdit();\n    }\n  };\n\n  // Hide step controls entirely (used in nested field editor)\n  if (hideStepControls) {\n    return null;\n  }\n\n  // If there's only one step, don't show the step tabs UI\n  if (steps.length <= 1) {\n    return (\n      <div className={cn(\"flex items-center gap-2 mb-4\", className)}>\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={onAddStep}\n          className=\"gap-1\"\n        >\n          <Plus className=\"h-4 w-4\" />\n          Add Step\n        </Button>\n        <span className=\"text-sm text-muted-foreground\">\n          Add a step to create a multi-step form\n        </span>\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn(\"flex items-center gap-2 mb-4 flex-wrap\", className)}>\n      {steps.map((step, index) => (\n        <div\n          key={step.id}\n          className={cn(\n            \"group flex items-center gap-1 px-3 py-1.5 rounded-md border transition-colors\",\n            activeStepIndex === index\n              ? \"bg-primary text-primary-foreground border-primary\"\n              : \"bg-card hover:bg-muted border-border\"\n          )}\n        >\n          {editingIndex === index ? (\n            <div className=\"flex items-center gap-1\">\n              <Input\n                value={editValue}\n                onChange={(e) => setEditValue(e.target.value)}\n                onKeyDown={handleKeyDown}\n                className=\"h-6 w-24 text-sm px-1\"\n                autoFocus\n              />\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-6 w-6\"\n                onClick={handleConfirmEdit}\n              >\n                <Check className=\"h-3 w-3\" />\n              </Button>\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-6 w-6\"\n                onClick={handleCancelEdit}\n              >\n                <X className=\"h-3 w-3\" />\n              </Button>\n            </div>\n          ) : (\n            <>\n              <button\n                type=\"button\"\n                onClick={() => onActiveStepChange(index)}\n                className=\"text-sm font-medium\"\n              >\n                {step.title}\n              </button>\n              <div\n                className={cn(\n                  \"flex items-center gap-0.5 ml-1\",\n                  activeStepIndex === index\n                    ? \"opacity-70 hover:opacity-100\"\n                    : \"opacity-0 group-hover:opacity-100\"\n                )}\n              >\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className={cn(\n                    \"h-5 w-5\",\n                    activeStepIndex === index\n                      ? \"hover:bg-primary-foreground/20 text-primary-foreground\"\n                      : \"hover:bg-muted-foreground/20\"\n                  )}\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    handleStartEdit(index, step.title);\n                  }}\n                  title=\"Rename step\"\n                >\n                  <Pencil className=\"h-3 w-3\" />\n                </Button>\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className={cn(\n                    \"h-5 w-5\",\n                    activeStepIndex === index\n                      ? \"hover:bg-destructive/20 text-primary-foreground\"\n                      : \"hover:bg-destructive/20 hover:text-destructive\"\n                  )}\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    onDeleteStep(index);\n                  }}\n                  title=\"Delete step\"\n                >\n                  <Trash2 className=\"h-3 w-3\" />\n                </Button>\n              </div>\n            </>\n          )}\n        </div>\n      ))}\n      <Button\n        variant=\"outline\"\n        size=\"sm\"\n        onClick={onAddStep}\n        className=\"gap-1 h-8\"\n      >\n        <Plus className=\"h-4 w-4\" />\n        Add Step\n      </Button>\n    </div>\n  );\n}\n\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/types.ts",
      "content": "import type { z } from \"zod\";\nimport type { \n  JSONSchemaPropertyBase, \n  SerializableInputProps,\n  FieldType,\n  StringInputProps,\n  NumberInputProps,\n  BooleanInputProps,\n  DateInputProps,\n  EnumInputProps,\n  InputPropsByBackingType,\n} from \"../shared-form-types\";\n\n// Re-export discriminated input prop types from shared-form-types\nexport type {\n  SerializableInputProps,\n  StringInputProps,\n  NumberInputProps,\n  BooleanInputProps,\n  DateInputProps,\n  EnumInputProps,\n  InputPropsByBackingType,\n};\n\n// ============================================================================\n// STEP TYPES\n// ============================================================================\n\n/**\n * Represents a step in a multi-step form.\n */\nexport interface FormStep {\n  /** Unique identifier for the step */\n  id: string;\n  /** Display title for the step */\n  title: string;\n}\n\n/**\n * JSON Schema types for form builder I/O.\n * Extends the shared base types with form-builder specific needs.\n */\nexport interface JSONSchema {\n  type: \"object\";\n  properties: Record<string, JSONSchemaProperty>;\n  required?: string[];\n  $schema?: string;\n  /** Step definitions for multi-step forms (stored in schema meta) */\n  steps?: FormStep[];\n  additionalProperties?: boolean;\n}\n\n/**\n * JSON Schema property with form-builder metadata.\n * Extends the shared JSONSchemaPropertyBase for compatibility with auto-form.\n */\nexport interface JSONSchemaProperty extends Omit<JSONSchemaPropertyBase, \"type\" | \"enum\" | \"properties\" | \"items\"> {\n  /** JSON Schema type - required for form-builder fields */\n  type: string;\n  /** Enum values for select/radio fields (string-only for form-builder) */\n  enum?: string[];\n  /** Nested properties for object types (self-referential) */\n  properties?: Record<string, JSONSchemaProperty>;\n  /** Item schema for array types (self-referential) */\n  items?: JSONSchemaProperty;\n  /** Minimum items for array types */\n  minItems?: number;\n  /** Maximum items for array types */\n  maxItems?: number;\n  /** Step group index for multi-step forms (0-indexed) */\n  stepGroup?: number;\n}\n\n/**\n * Internal field representation used by form builder.\n */\nexport interface FormBuilderField {\n  id: string;\n  type: string;\n  props: FormBuilderFieldProps;\n  /** Nested fields for object type containers */\n  children?: FormBuilderField[];\n  /** Template fields defining the shape of each array item */\n  itemTemplate?: FormBuilderField[];\n  /** Step group index (0-indexed) for multi-step forms */\n  stepGroup?: number;\n}\n\n/**\n * Backing types supported by form-builder fields.\n */\nexport type BackingType = keyof InputPropsByBackingType;\n\n// ============================================================================\n// COMPONENT TYPE REGISTRY\n// ============================================================================\n\n/**\n * Registry mapping component type names to their backing Zod types.\n * This enables compile-time type checking for component definitions.\n */\nexport const COMPONENT_BACKING_TYPES = {\n  text: \"string\",\n  email: \"string\",\n  password: \"string\",\n  url: \"string\",\n  phone: \"string\",\n  textarea: \"string\",\n  number: \"number\",\n  checkbox: \"boolean\",\n  switch: \"boolean\",\n  select: \"enum\",\n  radio: \"enum\",\n  date: \"date\",\n  color: \"string\", // color picker stores hex string\n} as const;\n\n/**\n * All registered component type names.\n */\nexport type ComponentType = keyof typeof COMPONENT_BACKING_TYPES;\n\n/**\n * Get the backing type for a component type.\n */\nexport type BackingTypeFor<C extends ComponentType> = typeof COMPONENT_BACKING_TYPES[C];\n\n// ============================================================================\n// DISCRIMINATED FIELD PROPS BY BACKING TYPE\n// ============================================================================\n\n/**\n * Base properties shared by all form builder fields.\n */\nexport interface BaseFieldProps {\n  /** Display label for the field */\n  label: string;\n  /** Description text */\n  description?: string;\n  /** Whether the field is required */\n  required?: boolean;\n  /** Field type override (checkbox, date, select, radio, switch, etc.) */\n  fieldType?: FieldType;\n  /** Additional input props passed through to the field */\n  inputProps?: SerializableInputProps;\n}\n\n/**\n * Props for string-backed fields (text, email, password, url, phone, textarea).\n */\nexport interface StringFieldProps extends BaseFieldProps {\n  /** Placeholder text */\n  placeholder?: string;\n  /** Minimum length */\n  minLength?: number;\n  /** Maximum length */\n  maxLength?: number;\n  /** Regex pattern for validation */\n  pattern?: string;\n  /** HTML input type (text, email, password, tel, url) */\n  inputType?: string;\n  /** Default value */\n  defaultValue?: string;\n}\n\n/**\n * Props for number-backed fields.\n */\nexport interface NumberFieldProps extends BaseFieldProps {\n  /** Placeholder text */\n  placeholder?: string;\n  /** Minimum value */\n  min?: number;\n  /** Maximum value */\n  max?: number;\n  /** Default value */\n  defaultValue?: number;\n}\n\n/**\n * Props for boolean-backed fields (checkbox, switch).\n */\nexport interface BooleanFieldProps extends BaseFieldProps {\n  /** Default value */\n  defaultValue?: boolean;\n}\n\n/**\n * Props for date-backed fields.\n */\nexport interface DateFieldProps extends BaseFieldProps {\n  /** Minimum date */\n  minDate?: Date | string;\n  /** Maximum date */\n  maxDate?: Date | string;\n  /** Default value */\n  defaultValue?: Date | string;\n}\n\n/**\n * Props for enum-backed fields (select, radio).\n */\nexport interface EnumFieldProps extends BaseFieldProps {\n  /** Placeholder text (for select) */\n  placeholder?: string;\n  /** Options for the select/radio */\n  options?: string[];\n  /** Default value (must match one of the options) */\n  defaultValue?: string;\n}\n\n/**\n * Maps backing types to their corresponding field props.\n */\nexport interface FieldPropsByBackingType {\n  string: StringFieldProps;\n  number: NumberFieldProps;\n  boolean: BooleanFieldProps;\n  date: DateFieldProps;\n  enum: EnumFieldProps;\n}\n\n/**\n * Get the correct field props type for a backing type.\n */\nexport type FieldPropsFor<T extends BackingType> = FieldPropsByBackingType[T];\n\n/**\n * Union of all discriminated field props.\n */\nexport type TypedFieldProps = \n  | StringFieldProps\n  | NumberFieldProps\n  | BooleanFieldProps\n  | DateFieldProps\n  | EnumFieldProps;\n\n/**\n * Properties for a form builder field.\n * This is the runtime union type used when the backing type is not known.\n * \n * For type-safe field props, use the discriminated variants:\n * - StringFieldProps for text, email, password, url, phone, textarea\n * - NumberFieldProps for number fields\n * - BooleanFieldProps for checkbox, switch\n * - DateFieldProps for date fields\n * - EnumFieldProps for select, radio\n */\nexport interface FormBuilderFieldProps extends BaseFieldProps {\n  // String field props\n  placeholder?: string;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n  inputType?: string;\n  \n  // Number field props\n  min?: number;\n  max?: number;\n  \n  // Date field props\n  minDate?: Date | string;\n  maxDate?: Date | string;\n  \n  // Enum field props\n  options?: string[];\n  \n  // Array field props\n  minItems?: number;\n  maxItems?: number;\n  \n  // Default value (type depends on backing type)\n  defaultValue?: unknown;\n}\n\n/**\n * Typed component definition for a specific backing type.\n * \n * Use this when defining components to get type-safe field props:\n * \n * @example\n * ```typescript\n * const textField: TypedComponentDefinition<\"string\"> = {\n *   type: \"text\",\n *   backingType: \"string\",\n *   defaultProps: { label: \"Text\", placeholder: \"Enter text\" }, // ✓ type-safe\n *   // ...\n * };\n * ```\n */\nexport interface TypedComponentDefinition<T extends BackingType> {\n  /** Unique identifier for this component type */\n  type: ComponentType | string;\n  /** The backing Zod type for this component */\n  backingType: T;\n  /** Display name shown in the palette */\n  label: string;\n  /** Icon shown in the palette */\n  icon?: React.ComponentType<{ className?: string }>;\n  /** Default props when a new field is created - type-safe based on backing type */\n  defaultProps: Partial<FieldPropsFor<T>>;\n  /** Zod schema for the property panel */\n  propertiesSchema: z.ZodObject<z.ZodRawShape>;\n  /** Convert field props to JSON Schema property */\n  toJSONSchema: (props: FieldPropsFor<T>, isRequired: boolean) => JSONSchemaProperty;\n  /** Try to parse a JSON Schema property into this component type */\n  fromJSONSchema: (prop: JSONSchemaProperty, key: string, isRequired: boolean) => \n    { id: string; type: string; props: FieldPropsFor<T> } | null;\n  /** Optional custom preview component */\n  PreviewComponent?: React.ComponentType<{ field: FormBuilderField }>;\n}\n\n/**\n * Component definition provided by developers.\n * \n * This is the runtime type used when the backing type is not known at compile time.\n * For type-safe definitions, use `TypedComponentDefinition<T>`.\n */\nexport interface FormBuilderComponentDefinition {\n  /** Unique identifier for this component type */\n  type: string;\n  /** The backing Zod type for this component (optional for backwards compatibility) */\n  backingType?: BackingType;\n  /** Display name shown in the palette */\n  label: string;\n  /** Icon shown in the palette */\n  icon?: React.ComponentType<{ className?: string }>;\n  /** Default props when a new field is created */\n  defaultProps: Partial<FormBuilderFieldProps>;\n  /** Zod schema for the property panel */\n  propertiesSchema: z.ZodObject<z.ZodRawShape>;\n  /** Convert field props to JSON Schema property */\n  toJSONSchema: (props: FormBuilderFieldProps, isRequired: boolean) => JSONSchemaProperty;\n  /** Try to parse a JSON Schema property into this component type */\n  fromJSONSchema: (prop: JSONSchemaProperty, key: string, isRequired: boolean) => FormBuilderField | null;\n  /** Optional custom preview component */\n  PreviewComponent?: React.ComponentType<{ field: FormBuilderField }>;\n}\n\n/**\n * Helper to create a type-safe component definition.\n * The returned definition is assignable to FormBuilderComponentDefinition.\n */\nexport function defineComponent<T extends BackingType>(\n  def: TypedComponentDefinition<T>\n): FormBuilderComponentDefinition {\n  return def as unknown as FormBuilderComponentDefinition;\n}\n\n/**\n * Form builder context for sharing state\n */\nexport interface FormBuilderContextValue {\n  fields: FormBuilderField[];\n  components: FormBuilderComponentDefinition[];\n  mode: \"build\" | \"preview\";\n  setFields: (fields: FormBuilderField[]) => void;\n  setMode: (mode: \"build\" | \"preview\") => void;\n  addField: (componentType: string, index?: number) => void;\n  updateField: (id: string, props: Partial<FormBuilderFieldProps>) => void;\n  removeField: (id: string) => void;\n  moveField: (fromIndex: number, toIndex: number) => void;\n}\n\n/**\n * Drag data types for dnd-kit\n */\nexport interface PaletteDragData {\n  type: \"palette\";\n  componentType: string;\n}\n\nexport interface FieldDragData {\n  type: \"field\";\n  fieldId: string;\n  index: number;\n}\n\nexport type DragData = PaletteDragData | FieldDragData;\n",
      "type": "registry:component"
    },
    {
      "path": "components/form-builder/validation-schemas.ts",
      "content": "import { z } from \"zod\";\n\n/**\n * Validation Schemas Registry\n *\n * This file defines type-safe validation schemas for the form-builder properties editor.\n * Based on the Zod serialization analysis, only serializable properties are included.\n *\n * Usage:\n *   propertiesSchema: baseMetaSchema\n *     .merge(VALIDATION_SCHEMAS[backingType])\n *     .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS[backingType] }))\n */\n\n// ============================================================================\n// BASE META SCHEMAS\n// ============================================================================\n\n/**\n * Base meta properties (universal - all field types)\n * Includes: label, description, required\n */\nexport const baseMetaSchema = z.object({\n  label: z.string().min(1).meta({ label: \"Label\" }),\n  description: z.string().optional().meta({ label: \"Description\" }),\n  required: z\n    .boolean()\n    .default(false)\n    .meta({ label: \"Required\", fieldType: \"switch\" }),\n});\n\n/**\n * Extended base with placeholder (for text-like fields only)\n * Use for: text, email, password, url, phone, textarea, number, select\n */\nexport const baseMetaSchemaWithPlaceholder = baseMetaSchema.merge(\n  z.object({\n    placeholder: z.string().optional().meta({ label: \"Placeholder\" }),\n  })\n);\n\n// ============================================================================\n// DEFAULT VALUE SCHEMAS\n// ============================================================================\n\n/**\n * Default value schemas - typed per backing Zod type\n * Serializes to JSON Schema as { \"default\": value }\n */\nexport const DEFAULT_VALUE_SCHEMAS = {\n  string: z.string().optional().meta({ label: \"Default Value\" }),\n  number: z.number().optional().meta({ label: \"Default Value\" }),\n  boolean: z\n    .boolean()\n    .default(false)\n    .meta({ label: \"Default Value\", fieldType: \"switch\" }),\n  date: z.date().optional().meta({ label: \"Default Date\", fieldType: \"date\" }),\n  enum: z\n    .string()\n    .optional()\n    .meta({\n      label: \"Default Value\",\n      description: \"Must match one of the options\",\n    }),\n} as const;\n\n// ============================================================================\n// TYPE-SPECIFIC VALIDATION SCHEMAS\n// ============================================================================\n\n/**\n * String validation schema\n * Serializes to: minLength, maxLength, pattern\n */\nexport const stringValidationSchema = z.object({\n  minLength: z\n    .number()\n    .int()\n    .min(0)\n    .optional()\n    .meta({ label: \"Min Length\" }),\n  maxLength: z\n    .number()\n    .int()\n    .min(1)\n    .optional()\n    .meta({ label: \"Max Length\" }),\n  // Note: pattern/regex is serializable but requires careful UX for input\n  // Uncomment to enable:\n  // pattern: z.string().optional().meta({ label: \"Pattern (Regex)\" }),\n});\n\n/**\n * Number validation schema\n * Serializes to: minimum, maximum, multipleOf\n */\nexport const numberValidationSchema = z.object({\n  min: z.number().optional().meta({ label: \"Minimum\" }),\n  max: z.number().optional().meta({ label: \"Maximum\" }),\n  // Note: multipleOf is serializable but less commonly used\n  // Uncomment to enable:\n  // multipleOf: z.number().optional().meta({ label: \"Multiple Of\" }),\n});\n\n/**\n * Boolean validation schema\n * No additional validation constraints - booleans are just true/false\n */\nexport const booleanValidationSchema = z.object({});\n\n/**\n * Date validation schema\n * Serializes to: formatMinimum, formatMaximum (with date-time override)\n * Note: Currently date min/max requires custom handling in toJSONSchema\n */\nexport const dateValidationSchema = z.object({\n  // Date min/max can be added when the date serialization is refined\n  // minDate: z.date().optional().meta({ label: \"Minimum Date\", fieldType: \"date\" }),\n  // maxDate: z.date().optional().meta({ label: \"Maximum Date\", fieldType: \"date\" }),\n});\n\n/**\n * Enum options schema (for select and radio)\n * The options textarea - user enters one option per line\n */\nexport const enumOptionsSchema = z.object({\n  options: z.string().meta({\n    label: \"Options (one per line)\",\n    fieldType: \"textarea\",\n    description: \"Enter each option on a new line\",\n  }),\n});\n\n/**\n * Object validation schema\n * Object fields don't have their own validation - validation comes from children\n */\nexport const objectValidationSchema = z.object({});\n\n/**\n * Array validation schema\n * Serializes to: minItems, maxItems\n */\nexport const arrayValidationSchema = z.object({\n  minItems: z\n    .number()\n    .int()\n    .min(0)\n    .optional()\n    .meta({ label: \"Min Items\" }),\n  maxItems: z\n    .number()\n    .int()\n    .min(1)\n    .optional()\n    .meta({ label: \"Max Items\" }),\n});\n\n// ============================================================================\n// VALIDATION SCHEMAS REGISTRY\n// ============================================================================\n\n/**\n * Registry mapping backing Zod type to validation schema\n * Only includes properties confirmed serializable by the analysis script\n */\nexport const VALIDATION_SCHEMAS = {\n  string: stringValidationSchema,\n  number: numberValidationSchema,\n  boolean: booleanValidationSchema,\n  date: dateValidationSchema,\n  enum: enumOptionsSchema,\n  object: objectValidationSchema,\n  array: arrayValidationSchema,\n} as const;\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n// Note: The composePropertiesSchema helper was removed due to complex TypeScript \n// inference issues with Zod's merge types. Instead, compose schemas directly:\n//\n// Example usage:\n//   baseMetaSchemaWithPlaceholder\n//     .merge(stringValidationSchema)\n//     .merge(z.object({ defaultValue: DEFAULT_VALUE_SCHEMAS.string }))\n\n// ============================================================================\n// TYPE EXPORTS\n// ============================================================================\n\nexport type BackingZodType = keyof typeof VALIDATION_SCHEMAS;\nexport type BaseMetaSchemaType = z.infer<typeof baseMetaSchema>;\nexport type BaseMetaSchemaWithPlaceholderType = z.infer<\n  typeof baseMetaSchemaWithPlaceholder\n>;\n",
      "type": "registry:component"
    },
    {
      "path": "lib/schema-converter.ts",
      "content": "/**\n * Unified Schema Converter Module\n * \n * Provides consistent bidirectional conversion between Zod schemas and JSON Schema,\n * handling all edge cases in one place:\n * \n * 1. Date handling: z.date() ↔ { type: \"string\", format: \"date-time\" }\n * 2. Steps metadata: Preserves multi-step form configuration\n * 3. Step group mapping: Tracks which fields belong to which step\n * 4. Date constraints: Preserves min/max date validations\n * \n * Usage:\n * ```ts\n * // Zod → JSON Schema (for storage/transport)\n * const jsonSchema = zodToFormSchema(myZodSchema);\n * \n * // JSON Schema → Zod (for validation)\n * const zodSchema = formSchemaToZod(jsonSchema);\n * ```\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod\";\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface FormStep {\n  id: string;\n  title: string;\n}\n\nexport interface FormSchemaMetadata {\n  /** Multi-step form step definitions */\n  steps?: FormStep[];\n  /** Map of field names to their step indices */\n  stepGroupMap?: Record<string, number>;\n}\n\ninterface JsonSchemaProperty {\n  type?: string;\n  format?: string;\n  formatMinimum?: string;\n  formatMaximum?: string;\n  stepGroup?: number;\n  properties?: Record<string, JsonSchemaProperty>;\n  [key: string]: unknown;\n}\n\ninterface FormJsonSchema {\n  type?: string;\n  properties?: Record<string, JsonSchemaProperty>;\n  required?: string[];\n  steps?: FormStep[];\n  stepGroupMap?: Record<string, number>;\n  [key: string]: unknown;\n}\n\n// ============================================================================\n// ZOD → JSON SCHEMA (for storage/transport)\n// ============================================================================\n\n/**\n * Convert a Zod schema to JSON Schema with proper handling for:\n * - z.date() → { type: \"string\", format: \"date-time\" }\n * - Date min/max constraints → formatMinimum/formatMaximum\n * - Steps metadata (if provided via schema.meta() or explicit metadata param)\n * \n * @param schema - The Zod schema to convert\n * @param metadata - Optional explicit metadata to include (overrides schema meta)\n */\nexport function zodToFormSchema<T extends z.ZodType>(\n  schema: T,\n  metadata?: FormSchemaMetadata\n): FormJsonSchema {\n  const jsonSchema = z.toJSONSchema(schema, {\n    unrepresentable: \"any\",\n    override: (ctx) => {\n      const def = (ctx.zodSchema as any)?._zod?.def;\n      if (def?.type === \"date\") {\n        ctx.jsonSchema.type = \"string\";\n        ctx.jsonSchema.format = \"date-time\";\n        \n        // Preserve min/max date constraints\n        // In Zod v4, these are available as minDate/maxDate on the schema object\n        const zodSchema = ctx.zodSchema as any;\n        if (zodSchema.minDate) {\n          ctx.jsonSchema.formatMinimum = zodSchema.minDate;\n        }\n        if (zodSchema.maxDate) {\n          ctx.jsonSchema.formatMaximum = zodSchema.maxDate;\n        }\n      }\n    },\n  }) as FormJsonSchema;\n  \n  // If explicit metadata is provided, use it\n  if (metadata?.steps) {\n    jsonSchema.steps = metadata.steps;\n  }\n  if (metadata?.stepGroupMap) {\n    jsonSchema.stepGroupMap = metadata.stepGroupMap;\n  }\n  \n  return jsonSchema;\n}\n\n// ============================================================================\n// JSON SCHEMA → ZOD (for validation)\n// ============================================================================\n\n/**\n * Extract step group map from JSON Schema properties.\n * Looks for stepGroup property on each field.\n */\nfunction extractStepGroupMap(jsonSchema: FormJsonSchema): Record<string, number> {\n  const stepGroupMap: Record<string, number> = {};\n  const properties = jsonSchema.properties;\n  \n  if (!properties) return stepGroupMap;\n  \n  for (const [fieldName, fieldSchema] of Object.entries(properties)) {\n    if (typeof fieldSchema.stepGroup === \"number\") {\n      stepGroupMap[fieldName] = fieldSchema.stepGroup;\n    }\n  }\n  \n  return stepGroupMap;\n}\n\n/**\n * Find date fields with min/max constraints that need validation.\n */\nfunction findDateFieldsWithConstraints(\n  jsonSchema: FormJsonSchema\n): Record<string, { min?: string; max?: string }> {\n  const dateFields: Record<string, { min?: string; max?: string }> = {};\n  const properties = jsonSchema.properties;\n  \n  if (!properties) return dateFields;\n  \n  for (const [key, prop] of Object.entries(properties)) {\n    if (prop.type === \"string\" && prop.format === \"date-time\") {\n      if (prop.formatMinimum || prop.formatMaximum) {\n        dateFields[key] = {\n          min: prop.formatMinimum,\n          max: prop.formatMaximum,\n        };\n      }\n    }\n  }\n  \n  return dateFields;\n}\n\n/**\n * Add date constraint validations to a schema via superRefine.\n */\nfunction addDateValidations(\n  schema: z.ZodType,\n  dateFieldsWithConstraints: Record<string, { min?: string; max?: string }>\n): z.ZodType {\n  if (Object.keys(dateFieldsWithConstraints).length === 0) {\n    return schema;\n  }\n  \n  return schema.superRefine((data: any, ctx) => {\n    for (const [key, constraints] of Object.entries(dateFieldsWithConstraints)) {\n      const value = data[key];\n      if (value === undefined || value === null || value === \"\") continue;\n      \n      const dateValue = new Date(value);\n      if (isNaN(dateValue.getTime())) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: \"Invalid date\",\n          path: [key],\n        });\n        continue;\n      }\n      \n      if (constraints.min) {\n        const minDate = new Date(constraints.min);\n        if (dateValue < minDate) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: `Date must be after ${minDate.toLocaleDateString()}`,\n            path: [key],\n          });\n        }\n      }\n      \n      if (constraints.max) {\n        const maxDate = new Date(constraints.max);\n        if (dateValue > maxDate) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: `Date must be before ${maxDate.toLocaleDateString()}`,\n            path: [key],\n          });\n        }\n      }\n    }\n  });\n}\n\n/**\n * Re-attach steps metadata to a Zod schema via .meta().\n * This is necessary because z.fromJSONSchema() doesn't preserve custom properties.\n */\nfunction attachStepsMetadata(\n  schema: z.ZodType,\n  jsonSchema: FormJsonSchema\n): z.ZodType {\n  const steps = jsonSchema.steps;\n  if (!steps || steps.length === 0) {\n    return schema;\n  }\n  \n  // Get stepGroupMap from either root level or extract from properties\n  const stepGroupMap = jsonSchema.stepGroupMap ?? extractStepGroupMap(jsonSchema);\n  \n  return schema.meta({\n    steps,\n    stepGroupMap,\n  });\n}\n\n/**\n * Convert JSON Schema to Zod schema with proper handling for:\n * - { type: \"string\", format: \"date-time\" } → date field (with constraints)\n * - Steps metadata re-attachment (preserved via .meta())\n * - Step group mapping\n * \n * @param jsonSchema - The JSON Schema to convert\n * @returns A Zod schema ready for validation, with all metadata preserved\n */\nexport function formSchemaToZod(jsonSchema: FormJsonSchema): z.ZodType {\n  // 1. Create base schema from JSON Schema\n  let schema = z.fromJSONSchema(jsonSchema as z.core.JSONSchema.JSONSchema);\n  \n  // 2. Add date constraint validations\n  const dateFieldsWithConstraints = findDateFieldsWithConstraints(jsonSchema);\n  schema = addDateValidations(schema, dateFieldsWithConstraints);\n  \n  // 3. Re-attach steps metadata so SteppedAutoForm can extract it\n  schema = attachStepsMetadata(schema, jsonSchema);\n  \n  return schema;\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check if a JSON Schema has multi-step configuration.\n */\nexport function hasSteps(jsonSchema: FormJsonSchema): boolean {\n  return Array.isArray(jsonSchema.steps) && jsonSchema.steps.length > 0;\n}\n\n/**\n * Get steps from a JSON Schema.\n */\nexport function getSteps(jsonSchema: FormJsonSchema): FormStep[] {\n  return jsonSchema.steps ?? [];\n}\n\n/**\n * Get the step group map from a JSON Schema.\n * Returns a map of field names to step indices.\n */\nexport function getStepGroupMap(jsonSchema: FormJsonSchema): Record<string, number> {\n  return jsonSchema.stepGroupMap ?? extractStepGroupMap(jsonSchema);\n}\n\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:block"
}